I"X<h2 id="architecture-component">Architecture Component</h2>
<p>Architecture Component 예제를 공부하면서 주요 기능으로 자리잡고 있는 <code class="language-plaintext highlighter-rouge">LiveData</code>, <code class="language-plaintext highlighter-rouge">ViewModel</code>, <code class="language-plaintext highlighter-rouge">Room Database</code>에 대하여 정리한 글입니다.</p>

<p float="center">
<img src="/assets/images/png/architectureComponent.png" width="100%" />
</p>
<p>이미지 출처 및 참고자료 <br />
<a href="https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin?hl=ko#1">https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin?hl=ko#1</a></p>

<p>이미지에서 <code class="language-plaintext highlighter-rouge">LiveData</code>를 살펴보면 ‘UI에 필요한 모든 데이터를 보유’하고 ‘observation을 사용하여 ui 변경사항을 통보’ 한다고 되어있습니다. <br />
안드로이드 공식문서에서 설명하는 <code class="language-plaintext highlighter-rouge">LiveData</code>에 대한 설명과 장점을 살펴보고 예제를 통해 어떻게 동작하는지 알아보겠습니다.</p>

<p>공식문서
<a href="https://developer.android.com/topic/libraries/architecture/livedata?hl=ko">https://developer.android.com/topic/libraries/architecture/livedata?hl=ko</a></p>

<h2 id="livedata란-무엇인가"><code class="language-plaintext highlighter-rouge">LiveData</code>란 무엇인가?</h2>
<p>데이터가 변경될 때 반응하는 <code class="language-plaintext highlighter-rouge">View</code>가 있다고 가정했을 때 데이터가 어떻게 저장되느냐에 따라 이것이 까다로울 수 있다. 앱의 여러가지 <code class="language-plaintext highlighter-rouge">View</code>에서 데이터 변경을 관찰하다 보면 코드줄이 길어지고 찾기 힘들어지면서 Test와 디버깅을 어렵게 만든다. <code class="language-plaintext highlighter-rouge">LiveData</code>는 이러한 문제를 해결한다.</p>
<ul>
  <li>식별 가능한 데이터 홀더 클래스</li>
  <li>일반 클래스와 달리 수명주기를 인식함</li>
  <li>activity, fragment, service등의 앱 구성요소 수명주기를 고려함</li>
  <li>수명주기 인식을 통해 활성상태에 있는 앱 구성요소의 관찰자만 업데이트 함<br />
```
참고:
LiveData를 Room과 독립적으로 사용할 경우 데이터 업데이트를 관리해야한다. 
LiveData에는 저장된 데이터를 업데이트하는 데에 대한 공식적은 방법이 없다.</li>
</ul>

<p>LiveData 저장된 데이터를 업데이트 하려면 MutableLiveData를 사용해야한다. 
method -&gt; setValue(T), postValue(T)
일반적으로 MutableLiveData는 ViewModel 내에서 사용된다.
ViewModel은 immutable LiveData 객체만 Observers에게 노출시킨다.
```</p>

<h4 id="livedata의-장점"><code class="language-plaintext highlighter-rouge">LiveData</code>의 장점</h4>
<ul>
  <li>UI와 데이터 상태의 일치 보장
    <ul>
      <li><code class="language-plaintext highlighter-rouge">LiveData</code>는 수명주기 상태가 변경될 때 <code class="language-plaintext highlighter-rouge">Observer</code> 객체에 알림</li>
      <li>코드를 통합하여 <code class="language-plaintext highlighter-rouge">Observer</code>객체에 UI를 업데이트</li>
      <li>데이터가 변경될 때마다 관찰자가 UI를 업데이트 함</li>
    </ul>
  </li>
  <li>메모리누출 없음
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Lifecylce</code> 객체와 관찰자가 결합되어 있고 수명주기가 끝나면 자동 삭제됨</li>
    </ul>
  </li>
  <li>중지된 activity로 인한 비정상 종료가 없음
    <ul>
      <li>관찰자의 수명주기가 비활성 상태이면 관찰자는 <code class="language-plaintext highlighter-rouge">LiveData</code> 이벤트를 수신하지 않음</li>
    </ul>
  </li>
  <li>수명주기를 수동으로 처리하지 않음
    <ul>
      <li>UI 구성요소는 관련 데이터를 관찰하기만 할 뿐 관찰을 중지하거나 다시 시작하지 않음</li>
      <li><code class="language-plaintext highlighter-rouge">LiveData</code>는 관찰하는 동안 관련 수명주기 상태의 변경을 인식하여 자동으로 관리</li>
    </ul>
  </li>
  <li>최신 데이터 유지
    <ul>
      <li>수명 주기가 비활성화 되고 다시 활성화 될 때 최신 데이터를 수신</li>
      <li>ex) 백그라운드에 있던 activity가 포그라운드로 돌아온 직후 최신 데이터 수신</li>
    </ul>
  </li>
  <li>적절한 구성 변경
    <ul>
      <li>구성 변경(ex-&gt;기기회전)으로 인해 activity, fragment 등이 다시 생성되면 사용할 수 있는 최신정보 를 즉시수신</li>
    </ul>
  </li>
  <li>리소스 공유
    <ul>
      <li>맵에서 시스템 서비스를 공유할 수 있도록 싱글톤 패턴을 사용하는 <code class="language-plaintext highlighter-rouge">LiveData</code> 객체를 확장하여 시스템 서비스를 래핑</li>
      <li><code class="language-plaintext highlighter-rouge">LiveData</code> 객체가 시스템 서비스에 한 번 연결되면 리소스가 필요한 모든 관찰자가 <code class="language-plaintext highlighter-rouge">LiveData</code> 객체를 볼 수 있음</li>
    </ul>
  </li>
</ul>
:ET