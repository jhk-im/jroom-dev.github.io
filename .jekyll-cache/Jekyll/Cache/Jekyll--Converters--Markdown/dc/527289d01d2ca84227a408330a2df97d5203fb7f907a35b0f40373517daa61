I"<p>참고자료
<a href="https://developer.android.com/topic/libraries/architecture/livedata?hl=ko">https://developer.android.com/topic/libraries/architecture/livedata?hl=ko</a></p>

<h2 id="architecture-component-example">Architecture Component Example</h2>
<p><a href="https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin?hl=ko#1">https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin?hl=ko#1</a></p>

<p>Architecture Component 예제를 공부하면서 주요 기능으로 자리잡고 있는 <code class="language-plaintext highlighter-rouge">LiveData</code>, <code class="language-plaintext highlighter-rouge">ViewModel</code>, <code class="language-plaintext highlighter-rouge">Room Database</code>에 대하여 정리한 글입니다.</p>

<h2 id="livedata란-무엇인가"><code class="language-plaintext highlighter-rouge">LiveData</code>란 무엇인가?</h2>

<ul>
  <li>식별 가능한 데이터 홀더 클래스</li>
  <li>일반 클래스와 달리 수명주기를 인식함</li>
  <li>activity, fragment, service등의 앱 구성요소 수명주기를 고려함</li>
  <li>수명주기 인식을 통해 활성상태에 있는 앱 구성요소의 관찰자만 업데이트 함</li>
</ul>

<h4 id="observer"><code class="language-plaintext highlighter-rouge">Observer</code></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Observer</code> 클래스로 표현되는 관찰자의 수명주기가 <code class="language-plaintext highlighter-rouge">STARTED</code> 또는 <code class="language-plaintext highlighter-rouge">RESUMED</code> 상태이면 <code class="language-plaintext highlighter-rouge">LiveData</code>가 관찰자를 활성 상태로 간주하여 업데이트 정보를 알림</li>
  <li><code class="language-plaintext highlighter-rouge">LiveData</code> 객체를 보기 위해 등록된 비활성 관찰자는 변경사항에 관한 알림을 받지 않음</li>
</ul>

<h4 id="lifecycleowner"><code class="language-plaintext highlighter-rouge">LifecycleOwner</code></h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">LifecycleOwner</code> 인터페이스를 구현하는 객체와 페어링된 관찰자를 등록할 수있음</li>
  <li>이 관계를 사용하면 <code class="language-plaintext highlighter-rouge">Lifecycle</code> 상태가 <code class="language-plaintext highlighter-rouge">DESTROYED</code>로 변경될 때 관찰자를 삭제할 수 있음</li>
  <li>activity, fragment가 <code class="language-plaintext highlighter-rouge">LiveData</code> 객체를 안전하게 관찰할 수 있음</li>
  <li>수명주기가 끝나는 즉시 수신 거부되어 메모리 누출을 걱정하지 않아도 됨</li>
</ul>

<h2 id="livedata의-장점"><code class="language-plaintext highlighter-rouge">LiveData</code>의 장점</h2>
<h5 id="ui와-데이터-상태의-일치-보장">UI와 데이터 상태의 일치 보장</h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">LiveData</code>는 수명주기 상태가 변경될 때 <code class="language-plaintext highlighter-rouge">Observer</code> 객체에 알림</li>
  <li>코드를 통합하여 <code class="language-plaintext highlighter-rouge">Observer</code>객체에 UI를 업데이트</li>
  <li>데이터가 변경될 때마다 관찰자가 UI를 업데이트 함</li>
</ul>

<h5 id="메모리누출-없음">메모리누출 없음</h5>
<ul>
  <li>‘Lifecylce` 객체와 관찰자가 결합되어 있고 수명주기가 끝나면 자동 삭제됨</li>
</ul>

<h5 id="중지된-activity로-인한-비정상-종료가-없음">중지된 activity로 인한 비정상 종료가 없음</h5>
<ul>
  <li>관찰자의 수명주기가 비활성 상태이면 관찰자는 <code class="language-plaintext highlighter-rouge">LiveData</code> 이벤트를 수신하지 않음</li>
</ul>

<h5 id="수명주기를-수동으로-처리하지-않음">수명주기를 수동으로 처리하지 않음</h5>
<ul>
  <li>UI 구성요소는 관련 데이터를 관찰하기만 할 뿐 관찰을 중지하거나 다시 시작하지 않음</li>
  <li><code class="language-plaintext highlighter-rouge">LiveData</code>는 관찰하는 동안 관련 수명주기 상태의 변경을 인식하여 자동으로 관리</li>
</ul>

<h5 id="최신-데이터-유지">최신 데이터 유지</h5>

<ul>
  <li>
    <p>수명 주기가 비활성화 되고 다시 활성화 될 때 최신 데이터를 수신</p>
  </li>
  <li>
    <p>ex) 백그라운드에 있던 activity가 포그라운드로 돌아온 직후 최신 데이터 수신</p>
  </li>
</ul>

<h5 id="적절한-구성-변경">적절한 구성 변경</h5>

<ul>
  <li>구성 변경(ex-&gt;기기회전)으로 인해 activity, fragment 등이 다시 생성되면 사용할 수 있는 최신정보 를 즉시수신</li>
</ul>

<h5 id="리소스-공유">리소스 공유</h5>

<ul>
  <li>
    <p>맵에서 시스템 서비스를 공유할 수 있도록 싱글톤 패턴을 사용하는 <code class="language-plaintext highlighter-rouge">LiveData</code> 객체를 확장하여 시스템 서비스를 래핑</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">LiveData</code> 객체가 시스템 서비스에 한 번 연결되면 리소스가 필요한 모든 관찰자가 <code class="language-plaintext highlighter-rouge">LiveData</code> 객체를 볼 수 있음</p>
  </li>
</ul>

<p><img src="/assets/images/png/architectureComponent.png" align="center" width="32%" /></p>

<h5 id="livedata-객체-활용"><code class="language-plaintext highlighter-rouge">LiveData</code> 객체 활용</h5>

<ul>
  <li>특정 유형의 데이터를 보유할 <code class="language-plaintext highlighter-rouge">LiveData</code> 인스턴스 생성
    <ul>
      <li>일반적으로 <code class="language-plaintext highlighter-rouge">ViewModel</code> 클래스 내에서 이루어짐</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">onChanged()</code> 메소드를 정의하는 <code class="language-plaintext highlighter-rouge">Observer</code> 객체를 생성
    <ul>
      <li><code class="language-plaintext highlighter-rouge">LiveData</code> 객체가 보유한 데이터가 변경될 때 발생하는 작업을 제어</li>
      <li>일반적으로 activity, fragment같은 ui 컨트롤러에 생성</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">observe()</code> 메소드를 사용하여 <code class="language-plaintext highlighter-rouge">LiveData</code> 객체에 <code class="language-plaintext highlighter-rouge">Observer</code> 객체를 연결
    <ul>
      <li><code class="language-plaintext highlighter-rouge">observe()</code> 메소드는 <code class="language-plaintext highlighter-rouge">LifecycleOwner</code> 객체를 사용</li>
      <li><code class="language-plaintext highlighter-rouge">Observer</code> 객체가 <code class="language-plaintext highlighter-rouge">LiveData</code> 객체를 구독하여 변경사항에 관한 알림을 받음</li>
      <li>일반적으로 activity, fragment 같은 ui 컨트롤러에 <code class="language-plaintext highlighter-rouge">Observer</code> 객체 연결</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">LiveData</code> 객체에 저장된 값을 업데이트 하면 연결된 <code class="language-plaintext highlighter-rouge">LifecycleOwner</code>가 활성 상태에 있는 한 등록된 모든 관찰자가 트리거된다. <code class="language-plaintext highlighter-rouge">LiveData</code>를 사용하면 UI컨트롤러 관찰자가 업데이트를 구독할 수 있다. <code class="language-plaintext highlighter-rouge">LiveData</code> 객체에서 보유한 데이터가 변경되면 응답으로 ui가 자동 업데이트 된다.</li>
</ul>
:ET