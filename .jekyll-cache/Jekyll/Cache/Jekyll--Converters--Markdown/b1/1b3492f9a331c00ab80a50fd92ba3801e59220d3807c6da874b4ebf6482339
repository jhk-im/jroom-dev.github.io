I"<h2 id="architecture-component">Architecture Component</h2>
<p>Architecture Component 예제를 공부하면서 주요 기능으로 자리잡고 있는 <code class="language-plaintext highlighter-rouge">RoomDatabase</code>, <code class="language-plaintext highlighter-rouge">LiveData</code>, <code class="language-plaintext highlighter-rouge">Repository</code> , <code class="language-plaintext highlighter-rouge">ViewModel</code>, 에 대하여 정리한 글이다.</p>

<p float="center">
<img src="/assets/images/png/architectureComponent.png" width="100%" />
</p>
<p>이미지 출처 및 참고자료 <br />
<a href="https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin?hl=ko#1">https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin?hl=ko#1</a></p>

<p>공식문서
<a href="https://developer.android.com/topic/libraries/architecture/livedata?hl=ko">https://developer.android.com/topic/libraries/architecture/livedata?hl=ko</a></p>

<h2 id="roomdatabase"><code class="language-plaintext highlighter-rouge">RoomDatabase</code>?</h2>
<p>룸은 SQLite 데이터베이스 위에 있는 데이터베이스 계층이다.
룸은 SQLiteOpenHelper로 처리하던 일상적인 작업을 처리한다.
룸은 DAO를 사용하여 데이터베이스에 쿼리를 발급한다.
기본적으로, 낮은 UI 성능을 피하기 위해 Room은 메인 스레드에 쿼리를 발행하는 것을 허용하지 않는다. 룸 쿼리가 LiveData를 반환하면 쿼리는 백그라운드 스레드에서 비동기식으로 자동으로 실행된다.
룸은 SQLite 문의 컴파일 시간 검사를 제공한다</p>

<h4 id="entity"><code class="language-plaintext highlighter-rouge">Entity</code></h4>
<h4 id="dao"><code class="language-plaintext highlighter-rouge">DAO</code></h4>
<h4 id="roomdatabase-1"><code class="language-plaintext highlighter-rouge">RoomDatabase</code></h4>
<h2 id="livedata"><code class="language-plaintext highlighter-rouge">LiveData</code>?</h2>
<p>데이터가 변경될 때 반응하는 <code class="language-plaintext highlighter-rouge">View</code>가 있다고 가정했을 때 데이터가 어떻게 저장되느냐에 따라 이것이 까다로울 수 있다. 앱의 여러가지 <code class="language-plaintext highlighter-rouge">View</code>에서 데이터 변경을 관찰하다 보면 코드줄이 길어지고 찾기 힘들어지면서 Test와 디버깅을 어렵게 만든다. <code class="language-plaintext highlighter-rouge">LiveData</code>는 이러한 문제를 해결한다.</p>

<ul>
  <li>식별 가능한 데이터 홀더 클래스</li>
  <li>일반 클래스와 달리 수명주기를 인식함</li>
  <li>activity, fragment, service등의 앱 구성요소 수명주기를 고려함</li>
  <li>수명주기 인식을 통해 활성상태에 있는 앱 구성요소의 관찰자만 업데이트 함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>참고:
LiveData를 Room과 독립적으로 사용할 경우 데이터 업데이트를 관리해야한다. 
LiveData에는 저장된 데이터를 업데이트하는 데에 대한 공식적은 방법이 없다. 

LiveData 저장된 데이터를 업데이트 하려면 MutableLiveData를 사용해야한다. 
method -&gt; setValue(T), postValue(T)
일반적으로 MutableLiveData는 ViewModel 내에서 사용된다.
ViewModel은 immutable LiveData 객체만 Observers에게 노출시킨다. 
</code></pre></div></div>
<p>다음은 안드로이드 공식문서에 나와있는 LiveData의 장점이다.</p>
<h4 id="livedata의-장점"><code class="language-plaintext highlighter-rouge">LiveData</code>의 장점</h4>
<ul>
  <li>UI와 데이터 상태의 일치 보장
    <ul>
      <li><code class="language-plaintext highlighter-rouge">LiveData</code>는 수명주기 상태가 변경될 때 <code class="language-plaintext highlighter-rouge">Observer</code> 객체에 알림</li>
      <li>코드를 통합하여 <code class="language-plaintext highlighter-rouge">Observer</code>객체에 UI를 업데이트</li>
      <li>데이터가 변경될 때마다 관찰자가 UI를 업데이트 함</li>
    </ul>
  </li>
  <li>메모리누출 없음
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Lifecylce</code> 객체와 관찰자가 결합되어 있고 수명주기가 끝나면 자동 삭제됨</li>
    </ul>
  </li>
  <li>중지된 activity로 인한 비정상 종료가 없음
    <ul>
      <li>관찰자의 수명주기가 비활성 상태이면 관찰자는 <code class="language-plaintext highlighter-rouge">LiveData</code> 이벤트를 수신하지 않음</li>
    </ul>
  </li>
  <li>수명주기를 수동으로 처리하지 않음
    <ul>
      <li>UI 구성요소는 관련 데이터를 관찰하기만 할 뿐 관찰을 중지하거나 다시 시작하지 않음</li>
      <li><code class="language-plaintext highlighter-rouge">LiveData</code>는 관찰하는 동안 관련 수명주기 상태의 변경을 인식하여 자동으로 관리</li>
    </ul>
  </li>
  <li>최신 데이터 유지
    <ul>
      <li>수명 주기가 비활성화 되고 다시 활성화 될 때 최신 데이터를 수신</li>
      <li>ex) 백그라운드에 있던 activity가 포그라운드로 돌아온 직후 최신 데이터 수신</li>
    </ul>
  </li>
  <li>적절한 구성 변경
    <ul>
      <li>구성 변경(ex-&gt;기기회전)으로 인해 activity, fragment 등이 다시 생성되면 사용할 수 있는 최신정보 를 즉시수신</li>
    </ul>
  </li>
  <li>리소스 공유
    <ul>
      <li>맵에서 시스템 서비스를 공유할 수 있도록 싱글톤 패턴을 사용하는 <code class="language-plaintext highlighter-rouge">LiveData</code> 객체를 확장하여 시스템 서비스를 래핑</li>
      <li><code class="language-plaintext highlighter-rouge">LiveData</code> 객체가 시스템 서비스에 한 번 연결되면 리소스가 필요한 모든 관찰자가 <code class="language-plaintext highlighter-rouge">LiveData</code> 객체를 볼 수 있음</li>
    </ul>
  </li>
</ul>

<h2 id="repository-"><code class="language-plaintext highlighter-rouge">Repository</code> ?</h2>
<p>리포지토리 클래스는 여러 데이터 소스에 대한 액세스를 추상화한다. 리포지토리는 아키텍처 구성요소 라이브러리에 속하지 않지만 코드 분리 및 아키텍처를 위한 권장 모범 사례다. Repository 클래스는 애플리케이션의 나머지 부분에 대한 데이터 액세스를 위한 깨끗한 API를 제공한다.</p>
:ET