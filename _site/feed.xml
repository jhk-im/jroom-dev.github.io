<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-10-26T01:36:06+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hun development blog</title><subtitle>Android &amp; Flutter &amp; Fullstack</subtitle><author><name>Hun</name></author><entry><title type="html">Using dagger-hilt in Android Example</title><link href="http://localhost:4000/android-kotlin/using-dagger-hilt-in-android-example/" rel="alternate" type="text/html" title="Using dagger-hilt in Android Example" /><published>2020-10-25T00:00:00+09:00</published><updated>2020-10-25T00:00:00+09:00</updated><id>http://localhost:4000/android-kotlin/using-dagger-hilt-in-android-example</id><content type="html" xml:base="http://localhost:4000/android-kotlin/using-dagger-hilt-in-android-example/">&lt;p float=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/gif/2020-10-2516-05.gif&quot; width=&quot;300&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;의존성 주입(Dependency Injection)을 구현하는 dagger-hilt eample을 공부하고 정리한 글&lt;/p&gt;

&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android?hl=ko&quot;&gt;Hilt - 공식문서&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://codelabs.developers.google.com/codelabs/android-hilt/?hl=ko#0&quot;&gt;Hilt - Example&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;dependency-injection과-hilt&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dependency Injection&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dependency Injection&lt;/code&gt; 줄여서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt;는 프로그래밍에 널리 사용되며 안드로이드 개발에 잘 맞는 기술이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt;의 원칠을 따르면 좋은 앱 아키텍처의 기초를 갖출 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt;의 장점&lt;/li&gt;
  &lt;li&gt;코드의 재사용성&lt;/li&gt;
  &lt;li&gt;리팩토링 용이성&lt;/li&gt;
  &lt;li&gt;테스트 용이성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;는 Android를 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt; 라이브러리이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt;를 구현하려면 모든 클래스와 그 종속성을 수동으로 구성하고 컨테이너를 사용하여 재사용할 수 있도록 관리해야한다.  &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;는 프로젝트의 모든 Android 구성요소에 컨테이너를 제공하고 컨테이너의 수명주기를 자동으로 관리함으로써 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt;를 수행하는 표준을 제공한다. &lt;br /&gt;
Android의 인기있는 라이브러리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dagger&lt;/code&gt;를 활용함으로써 완성된다.&lt;/p&gt;

&lt;p&gt;결국 해당 예제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt;를 이해하는 것을 중점으로 두고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;가 어떠한 편리함을 가져다 주는지 그리고 그안에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dagger&lt;/code&gt;가 어떻게 활용되는지를 알아가는것이 목표이다.&lt;/p&gt;

&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/training/dependency-injection/manual?hl=ko&quot;&gt;DI - 공식문서&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/training/dependency-injection/manual?hl=ko&quot;&gt;수동 DI - 공식문서&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/training/dependency-injection/dagger-basics?hl=ko&quot;&gt;Dagger - 공식문서&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;di의-기본사항&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt;의 기본사항&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/dependency-injection?hl=ko&quot;&gt;공식문서&lt;/a&gt; &lt;br /&gt;
클래스에는 흔히 다른 클래스의 참조가 필요하다. 예를들면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car&lt;/code&gt; 클래스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt;클래스 참조가 필요할 수 있다. 여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt;클래스를 종속 항목이라한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클래스가 필요한 종속 항목을 구성&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car&lt;/code&gt;클래스가 자체적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt; 인스턴스를 생성하여 초기화한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Car {

    private val engine = Engine()

    fun start() {
        engine.start()
    }
}

fun main(args: Array) {
    val car = Car()
    car.start()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;문제점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt;은 밀접하게 연관되어 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car&lt;/code&gt;인스턴스는 한가지 유형의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt;을 사용하므로 서브클래스 또는 대체구현을 쉽게 사용할 수 없다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt;이라는 강력한 종속항목은 테스트를 어렵게 만든다.
    &lt;ul&gt;
      &lt;li&gt;실제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt; 인스턴스를 사용하므로 테스트더블을 적용할 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;!! 종송항목의 활용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;객체를 매개변수로 제공받는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car&lt;/code&gt;생성자는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt;을 매개변수로 받는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Car(private val engine: Engine) {
    fun start() {
        engine.start()
    }
}

fun main(args: Array) {
    val engine = Engine()
    val car = Car(engine)
    car.start()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;장점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car&lt;/code&gt; 재사용성 증가
    &lt;ul&gt;
      &lt;li&gt;다양한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt;의 인스턴스를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car&lt;/code&gt;에 전달할 수 있다.
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ElectricEngine&lt;/code&gt;이라는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt;의 서브클래스를 정의하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car&lt;/code&gt;에 전달하면 추가 변경없이 계속 동작한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car&lt;/code&gt;테스트 편리함 증가
    &lt;ul&gt;
      &lt;li&gt;다양한 시나리오를 테스트할 수 있다.
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FakeEngine&lt;/code&gt;이라는 테스트 더블을 생성하여 다양한 테스트를 구성할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 방법과 더불어 필드 또는 setter를 삽입하는 다음의 방법이 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Car {
    lateinit var engine: Engine

    fun start() {
        engine.start()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예제는 라이브러리를 사용하지 않고 종속 항목을 직접 생성, 제공 및 관리하였다. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수동 종속항목 삽입&lt;/code&gt;이라한다.  종속항목과 클래스가 많아지면 이러한 수동작업이 불필요한 반복작업이 될 수 있으며 다음과 같은 문제점을 발생시킨다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대규모 앱에서 종속항목을 가져와 연결하려면 대량의 상용구 코드가 필요할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;다중 레이어 아키텍쳐에서 최상위 레이어의 객체를 생성하려면 아래에있는 레이어의 모든 종속항목을 제공해야 한다.
        &lt;ul&gt;
          &lt;li&gt;실제 자동차를 생각해보면 엔진, 변속기, 섀시 등 기타 수많은 부품이 필요하다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;종속항목을 생성하고 제공하는 프로세스를 자동화하여 위 문제를 해결하는것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dagger&lt;/code&gt;라이브러리이다. &lt;br /&gt;
	- 런타임 시 종속 항목을 연결하는 리플렉션기반 솔루션 &lt;br /&gt;
	- 컴파일 타임에 종속 항목을 연결하는 코드를 생성하는 정적 솔루션 &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dagger&lt;/code&gt;는 Kotlin 및 Android용으로 널리 사용되는 종속 항목 라이브러리이다. 종속항목 그래프를 자동으로 생성하고 관리하여 앱에서의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt; 사용도를 높인다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt; 의 2가지 대안 &lt;br /&gt;
1.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ServiceLocator&lt;/code&gt;를 사용하는 방법&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object ServiceLocator {
    fun getEngine(): Engine = Engine()
}

class Car {
    private val engine = ServiceLocator.getEngine()

    fun start() {
        engine.start()
    }
}

fun main(args: Array) {
    val car = Car()
    car.start()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;2.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;를 사용하는 방법&lt;/p&gt;

&lt;p&gt;해당 예제를 통해 구현하는 방법은 2번에 해당하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;는 Android에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt;사용을 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jetapck&lt;/code&gt; 권장 라이브러리이다.  프로젝트의 모든 Android 클래스에 컨테이너를 제공하고 수명 주기를 자동으로 관리함으로써 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt;를 실행하는 표준을 정의한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dagger&lt;/code&gt;가 제공하는 컴파일 타임 정확성, 런타임 성능, 확장성 및 Android 스튜디오 지원의 이점의 이유로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dagger&lt;/code&gt;를 기반으로 빌드되었다.&lt;/p&gt;

&lt;h2 id=&quot;set-up-hilt&quot;&gt;set up &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// build.gradle (Project)

buildscript {
    ...
    ext.hilt_version = '2.28-alpha'
    dependencies {
        ...
        classpath &quot;com.google.dagger:hilt-android-gradle-plugin:$hilt_version&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// build.gradle(app)

apply plugin: 'kotlin-kapt'
apply plugin: 'dagger.hilt.android.plugin'

android {
    ...
}

...
dependencies {
    ...
    implementation &quot;com.google.dagger:hilt-android:$hilt_version&quot;
    kapt &quot;com.google.dagger:hilt-android-compiler:$hilt_version&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//LogApplication.kt

@HiltAndroidApp
class LogApplication : Application() {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ServiceLocator&lt;/code&gt; 인스턴스가 사용되고 초기화되는 방식과 유사하게 앱의 수명주기에 부착된 컨테이너를 추가하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application()&lt;/code&gt; 클래스에 @HiltAndroidApp 어노테이션을 추가해야한다.
    &lt;ul&gt;
      &lt;li&gt;@HiltAndroidApp은 종속성 주입을 사용할 수 있는 응용프로그램의 기본클래스를 포함하여 Hilt의 코드 생성을 트리거한다.&lt;/li&gt;
      &lt;li&gt;애플리케이션 컨테이너는 앱의 상위 컨테이너로서 다른 컨테이너가 제공하는 종속성에 액세스할 수 있다든것을 의미한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;field-injection-with-hilt&quot;&gt;Field injection with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@AndroidEntryPoint
class LogsFragment : Fragment() {
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;클래스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt; 를 사용하여 의존성을 제공할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;LogsFragment &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UI controller&lt;/code&gt;가 Hilt를 사용하기 위해선 @AndroidEntryPoint 어노테이션을 추가해야한다.&lt;/li&gt;
      &lt;li&gt;Android 클래스 라이프사이클을 따르는 종속 컨테이너가 생성된다.&lt;/li&gt;
      &lt;li&gt;다음과 같은 Android 유형을 지원한다.
        &lt;ul&gt;
          &lt;li&gt;application(@HiltAndroidApp), activity, fragment, view, service, broadcast receiver
            &lt;ul&gt;
              &lt;li&gt;fragment는 AppcompletionActivity와 Jetpack 라이브러리 fragment를 확장하는 것만 지원한다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@AndroidEntryPoint
class LogsFragment : Fragment() {

    @Inject lateinit var logger: LoggerLocalDataSource
    @Inject lateinit var dateFormatter: DateFormatter

    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;는 @AndroidEntryPoint를 사용하여 LogsFragment의 수명주기에 연결된 종속 컨테이너를 생성하고 LogsFragment에 인스턴스를 주입할 수 있게 해준다.
    &lt;ul&gt;
      &lt;li&gt;주입할 필드에 @Inject 어노테이션을 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt; 주입 인스턴스를 만들 수 있다.
        &lt;ul&gt;
          &lt;li&gt;이것을 Field injection 이라한다.
            &lt;ul&gt;
              &lt;li&gt;@injection field는 private이면 안된다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Field injection을 수행하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;는 종속석 인스턴스 제공 방법을 알아야한다.
        &lt;ul&gt;
          &lt;li&gt;아직 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;는&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LoggerLocalDataSource&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataFormatter&lt;/code&gt;인스턴스를 어떻게 제공해야 하는지 모른다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hilt에-inject-종속성-제공&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;에 @Inject 종속성 제공&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// util/DateFormmater.kt
class DateFormatter @Inject constructor() { ... }
...

// data/LoggerLocalDatabase.kt
class LoggerLocalDataSource @Inject constructor(private val logDao: LogDao) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DateFormatter&lt;/code&gt;는 다른 클래스에 의존하지 않기 때문에 transitive dependencies를 걱정할 필요가 없다.
    &lt;ul&gt;
      &lt;li&gt;주입할 클래스의 생성자에 constructor와 함께 @Inject annotation을 추가하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;에 인스턴스 제공 방법을 알려주게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LoggerLocalDataSource&lt;/code&gt;도 마찬가지로 동일하게 추가해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;!!힐트가 가지고 있는 다른 유형의 인스턴스 제공 방법에 관한 정보를 바인딩이라고도 한다. &lt;br /&gt;
현재 힐트에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DateFormatter&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LoggerLocalDataSource&lt;/code&gt;의 두 가지 바인딩이 있는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;hilt에서-컨테이너-인스턴스-범위지정하기&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;에서 컨테이너 인스턴스 범위지정하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;는 다른 수명주기를 가진 컨테이너를 생산할 수 있기 때문에 각각에 적용되는 다양한 주석이있다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Singleton
class LoggerLocalDataSource @Inject constructor(private val logDao: LogDao) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Application 컨테이너에 대한 인스턴스 범위를 나타내는 주석은 @Singleton이다.
    &lt;ul&gt;
      &lt;li&gt;이 주석은 다른 유형의 종속성으로 사용되든 필드 주입이 필요하든 상관없이 항상 동일한 인스턴스를 제공하도록 한다.&lt;/li&gt;
      &lt;li&gt;Android 클래스에 부착된 모든 컨테이너에도 같은 논리를 적용할 수 있다.
        &lt;ul&gt;
          &lt;li&gt;항상 동일한 유형의 인스턴스를 제공하려면 @ActivityScoped를 활용한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;싱위 컨테이너에서 사용할 수 있는 바인딩은 하위 레벨에서도 사용할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;Application에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LoggerLocalDataSource&lt;/code&gt; 인스턴스를 사용할 경우 activity 및 fragment 컨테이너에서도 사용 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LoggerLocalDataSource&lt;/code&gt; 인스턴스를 제공하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;에서도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LogDao&lt;/code&gt; 인스턴스를 제공하는 방법을 알아야한다.&lt;/p&gt;

&lt;h2 id=&quot;hilt-modules&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt; modules&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// di/DataModule.kt

@InstallIn(ApplicationComponent::class)
@Module
object DatabaseModule {

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;module은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;에 바인딩을 추가하거나 다른 유형의 인스턴스를 제공하는 방법을 알려주기 위해 사용된다.&lt;/li&gt;
  &lt;li&gt;@Module 및 @InstallIn 으로 annotation을 추가한 클래스이다.
    &lt;ul&gt;
      &lt;li&gt;@Module은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;에게 해당 클래스가 module 임을 알려준다.&lt;/li&gt;
      &lt;li&gt;@InstallIn은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt; 구성 요소를 지정하여 바인딩을 사용할 수 있는 컨테이너를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;에 알려준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Module
object DatabaseModule {

    @Provides
    fun provideLogDao(database: AppDatabase): LogDao {
        return database.logDao()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린에서 @Provides 메소드만 포함하는 모듈은 객체 클래스가 될 수 있다.
    &lt;ul&gt;
      &lt;li&gt;이러한 방식으로 Provides는 최적화되고 생성된 코드에 인라인으로 연결된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt; module에서 @Provides를 메소드에 추가할 수 있어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;에게 생성자가 주입할 수 없는 유형을 제공하는 방법을 알려준다.
    &lt;ul&gt;
      &lt;li&gt;@Provides 처리된 메소드의 본체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;가 해당 유형의 인스턴스를 제공해야 할 때마다 실행된다.&lt;/li&gt;
      &lt;li&gt;@Provides 메소드의 반환 형식은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;에게 바인딩 유형 또는 해당 유형의 인스턴스 제공방법을 알려준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@InstallIn(ApplicationComponent::class)
@Module
object DatabaseModule {

    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext appContext: Context): AppDatabase {
        return Room.databaseBuilder(
            appContext,
            AppDatabase::class.java,
            &quot;logging.db&quot;
        ).build()
    }

    @Provides
    fun provideLogDao(database: AppDatabase): LogDao {
        return database.logDao()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AppDatabase&lt;/code&gt;가 전이적 종속성이기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;에게 그러한 유형의 인스턴스를 제공하는 방법도 알려줘야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AppDatabase&lt;/code&gt;는 Room에서 생성되기 때문에 프로젝트에서 소유하지 않는 또 다른 클래스 이기 때문에 @Provides 함수를 사용하여 제공할 수도 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;가 동일한 데이터베이스 인스턴스를 제공하도록 하기 위해 @Singleton 을 추가하였다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt; 컨테이너에는 사용자 정의 바인딩에 주입될 수 있는 기본 바인딩이 함께 제공된다.
    &lt;ul&gt;
      &lt;li&gt;@ApplicationContext 는 applicationContext를 액세스하기 위해 추가해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ui/MainActivity.kt

@AndroidEntryPoint
class MainActivity : AppCompatActivity() { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hilt&lt;/code&gt;는 LogsFragment에서 인스턴스를 주입하는 데 필요한 모든 정보를 가지고 있다.
    &lt;ul&gt;
      &lt;li&gt;하지만 앱을 실행하기 전에 Fragment를 호스팅하는 Activity를 알아야 작업을 할 수 있다.&lt;/li&gt;
      &lt;li&gt;@AndroidEntryPoint를 MainActivity에 추가한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;</content><author><name>Hun</name></author><category term="android-kotlin" /><category term="AndroidUI" /><category term="MVVM" /><summary type="html"></summary></entry><entry><title type="html">Data Binding in Android Example</title><link href="http://localhost:4000/data-binding-in-android-example/" rel="alternate" type="text/html" title="Data Binding in Android Example" /><published>2020-10-23T00:00:00+09:00</published><updated>2020-10-23T00:00:00+09:00</updated><id>http://localhost:4000/data-binding-in-android-example</id><content type="html" xml:base="http://localhost:4000/data-binding-in-android-example/">&lt;p float=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/gif/2020-10-2323-36.gif&quot; width=&quot;300&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Data Binding 예제를 정리한 글&lt;/p&gt;

&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding?hl=ko&quot;&gt;Data Binding - 공식문서&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://codelabs.developers.google.com/codelabs/android-databinding?hl=ko#0&quot;&gt;Data Binding - Example&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;data-binding&quot;&gt;Data Binding&lt;/h2&gt;
&lt;p float=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/png/dataBinding.png&quot; width=&quot;100%&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataBinding&lt;/code&gt; 라이브러리는 XML 레이아웃의 UI 구성요소를 선언적 형식을 사용하여 데이터 소스에 바인딩할 수 있도록 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Android Jetpack&lt;/code&gt; 라이브러리이다. &lt;br /&gt;
해당 예제는 정적 데이터와 일부 관측 가능한 데이터를 보여주는 하나의 화면을 가지고 있다. 데이터가 바뀌면 UI가 자동으로 업데이트 된다. 데이터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;에서 제공된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVVM&lt;/code&gt; (Model / View / ViewModel) 은 Data Binding과 잘 어울리는 프레젠테이션 계층 패턴이다.&lt;/p&gt;

&lt;h2 id=&quot;data-binding-example&quot;&gt;Data Binding Example&lt;/h2&gt;
&lt;p&gt;해당 예제는 총 6가지로 구현되어있다. 처음에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt; 만 사용하여 구현하였고 점차 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataBinding&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; 가 추가되면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVVM&lt;/code&gt;의 모습을 갖추어 간다.  추가되는 기능들이 어떤 변화를 주는지 제대로 파악하는것이 목표이다.&lt;/p&gt;

&lt;p&gt;처음에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;이 간략하게  정의되어있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ViewModel

class SimpleViewModel : ViewModel() {
    val name = &quot;Grace&quot;
    val lastName = &quot;Hopper&quot;
    var likes = 0
        private set // This is to prevent external modification of the variable.

    fun onLike() {
        likes++
    }

    val popularity: Popularity
        get() {
            return when {
                likes &amp;gt; 9 -&amp;gt; Popularity.STAR
                likes &amp;gt; 4 -&amp;gt; Popularity.POPULAR
                else -&amp;gt; Popularity.NORMAL
            }
        }
}

enum class Popularity {
    NORMAL,
    POPULAR,
    STAR
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;페이지의 데이터가 구현되어있다.
    &lt;ul&gt;
      &lt;li&gt;name, lastName, likes&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;enum =&amp;gt; NORMAL, POPULAR, START
    &lt;ul&gt;
      &lt;li&gt;likes 가 올라갈 때 마다 이미지가 변경될때 지정되는 enum type&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;onLike()
    &lt;ul&gt;
      &lt;li&gt;like를 1씩 추가하는 메소드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;databindingactivitykt&quot;&gt;DataBindingActivity.kt&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XML&lt;/code&gt;+ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Activity&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;로 구현되어있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// DataBindingActivity.kt

private val viewModel by lazy { ViewModelProvider(this).get(SimpleViewModel::class.java) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;SimpleViewModel로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt; 인스턴스를 생성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// DataBindingActivity.kt 

fun onLike(view: View) {
        viewModel.onLike()
        updateLikes()
    }

   private fun updateName() {
        findViewById&amp;lt;TextView&amp;gt;(R.id.plain_name).text = viewModel.name
        findViewById&amp;lt;TextView&amp;gt;(R.id.plain_lastname).text = viewModel.lastName
    }

   private fun updateLikes() {
        findViewById&amp;lt;TextView&amp;gt;(R.id.likes).text = viewModel.likes.toString()
        findViewById&amp;lt;ProgressBar&amp;gt;(R.id.progressBar).progress =
            (viewModel.likes * 100 / 5).coerceAtMost(100)
        val image = findViewById&amp;lt;ImageView&amp;gt;(R.id.imageView)

        val color = getAssociatedColor(viewModel.popularity, this)

        ImageViewCompat.setImageTintList(image, ColorStateList.valueOf(color))

        image.setImageDrawable(getDrawablePopularity(viewModel.popularity, this))
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;onLike(), updateName(), updateLikes() 모두 ui 데이터를 업데이트 하는데 사용되는 메소드다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findViewById&lt;/code&gt; 가 자중 사용된다.&lt;/li&gt;
      &lt;li&gt;updateLikes() 에서는 likes 숫자와 이미지 종류 + 색상까지 update 해야하므로 코드줄이 길어졌다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// DataBindingActivity.kt

    private fun getAssociatedColor(popularity: Popularity, context: Context): Int {
			. . .
    }

    private fun getDrawablePopularity(popularity: Popularity, context: Context): Drawable? {
			. . .
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;여기에 UI controller의 본분 UI를 표시하는 부분까지 만들어주어야 한다.&lt;/li&gt;
  &lt;li&gt;좋은코드인지 나쁜코드인지를 판별하기 보다는 현재의 코드에서 어떠한 부분들이 개선되는지를 살펴보는데 집중하도록 하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;solutionactivity1kt&quot;&gt;SolutionActivity1.kt&lt;/h4&gt;
&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataBinding&lt;/code&gt;을 추가해보자. &lt;br /&gt;
우선 builde.gradle에 다음을 추가하여 dataBinding을 활성화한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//build.gradle

...

android {
  buildFeatures {
    dataBinding true
  }
}
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XML&lt;/code&gt; 을 수정해보자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// activity_solution1.xml

&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&amp;gt;

    &amp;lt;data&amp;gt;

        &amp;lt;variable
            name=&quot;name&quot;
            type=&quot;String&quot;/&amp;gt;

        &amp;lt;variable
            name=&quot;lastName&quot;
            type=&quot;String&quot;/&amp;gt;
    &amp;lt;/data&amp;gt;

    &amp;lt;androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&amp;gt;
				
				...
    &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;
&amp;lt;/layout&amp;gt;
				
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;SolutionActivity1.kt의 레이아웃으로써 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConstraintLayout&lt;/code&gt; 이다.&lt;/li&gt;
  &lt;li&gt;레이아웃을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataBinding&lt;/code&gt;으로 변환하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;layout&amp;gt;&amp;lt;/layout&amp;gt;&lt;/code&gt; 태그로 감싸야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;data&amp;gt;&amp;lt;/data&amp;gt;&lt;/code&gt; 내부에 변수를 선언할 수 있고 다음과 같이 사용 가능하다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Some examples of complex layout expressions
android:text=&quot;@{String.valueOf(index + 1)}&quot;
android:visibility=&quot;@{age &amp;lt; 13 ? View.GONE : View.VISIBLE}&quot;
android:transitionName='@{&quot;image_&quot; + id}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;레이아웃 내부에서 형변환을 구현&lt;/li&gt;
      &lt;li&gt;조건문을 레이아웃 내부에 구현&lt;/li&gt;
      &lt;li&gt;레이아웃 내부에서 데이터를 유동적으로 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;!! 해당 기능은 많은 도움이 되지만 너무 복잡한 논리가 레이아웃 내부에 있으면 가독성이 떨어지며 유지보수를 어렵게 할 수 있다. 적절히 사용한다면 다음과 같은 이점을 얻을 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;앱의 성능 향상&lt;/li&gt;
  &lt;li&gt;메모리 누수 및 Null 포인터 예외 방지&lt;/li&gt;
  &lt;li&gt;UI 프레임워크 호출을 제거하여 활동 코드 간소화&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해당 예제는 다음과 같은 방식으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataBindidng&lt;/code&gt;을 활용한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Android:text=&quot;@{viewmodel.name}&quot;
Android:visibility=&quot;@{viewmodel.nameVisible}&quot;
Android:onClick=&quot;@{() -&amp;gt; viewmodel.onLike()}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Activity&lt;/code&gt;를 수정해보자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_solution1)

        val binding: ActivitySolution1Binding =
            DataBindingUtil.setContentView(this, R.layout.activity_solution1)

        binding.name = &quot;Ada&quot;
        binding.lastName = &quot;Lovelace&quot;

        updateLikes()
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;변동된 사항은 거의없고 onCreate() 내부에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ActivitySolution1Binding&lt;/code&gt;이라는 객체의 인스턴스를 생성하는 코드만 늘어났다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ActivitySolution1Binding&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;activity_solution.xml&lt;/code&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;layout&amp;gt;/layout&amp;gt;&lt;/code&gt;으로 감싸면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dataBinding&lt;/code&gt;이 자동으로 생성한 객체이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드만 늘어난거 아닌가?
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binding.name = &quot;Ada&quot;&lt;/code&gt; 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dataBinding&lt;/code&gt; 객체의 인스턴스를 얻는것만으로 내부에 있는 데이터를 변경할 수 있게 되었다.
        &lt;ul&gt;
          &lt;li&gt;큰 변화는 아니지만 이러한 변화가 어떤 유용함을 가져다 주는지 다음 solution을 통해 알아보도록 하자.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;solutionactivity2kt&quot;&gt;SolutionActivity2.kt&lt;/h4&gt;
&lt;p&gt;우선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XML&lt;/code&gt;을 다음과 같이 변경한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
&amp;lt;data&amp;gt;

  &amp;lt;variable
    name=&quot;viewmodel&quot;
    type=&quot;com.example.androidsamples.dataBinding.data.SimpleViewModel&quot;/&amp;gt;
&amp;lt;/data&amp;gt;			
...
&amp;lt;TextView
    android:id=&quot;@+id/plain_name&quot;
    ...
    android:text=&quot;@{viewmodel.name}&quot; /&amp;gt;
				
&amp;lt;TextView
    android:id=&quot;@+id/plain_lastname&quot;
    ...
    android:text=&quot;@{viewmodel.lastName}&quot;/&amp;gt;
       
&amp;lt;Button
    android:id=&quot;@+id/like_button&quot;
    ...
    android:onClick=&quot;@{() -&amp;gt; viewmodel.onLike()}&quot; /&amp;gt;
...
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;레이아웃 표현식은 @기호로 시작하여 {} 내부에 작성한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;data&amp;gt;&amp;lt;/data&amp;gt;&lt;/code&gt; 내부에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt; 자체를 객체로 작성하였다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TextView&lt;/code&gt;에 변경되는 로직을 관리하는 권한이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Activity&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;로 변경되었다.
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@{name}&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@{viewmodel.main}&lt;/code&gt;으로 변경되었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Button 의 onClick설정이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@{() -&amp;gt; viewmodel.onLike()}&lt;/code&gt;으로 변경되었다.
        &lt;ul&gt;
          &lt;li&gt;onLike() 메소드의 위치가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Activity&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;로 변경되었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Activity&lt;/code&gt;변동사항&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//onCreate()
...
    val binding: ActivitySolution2Binding=
    DataBindingUtil.setContentView(this, R.layout.activity_solution2)

    binding.viewmodel = viewModel
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setContentView(R.layout.activity_data_binding)&lt;/code&gt;가 완전히 사라지고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataBinding&lt;/code&gt;으로 변경되었다.&lt;/li&gt;
  &lt;li&gt;onLike() 함수가 사라지고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;내부에 구현되었으며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xml&lt;/code&gt;에서 사용한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataBinding&lt;/code&gt;객체로 레이아웃 데이터에 접근 할 수 있게되었지만 그 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;을 통해서 해야한다.
    &lt;ul&gt;
      &lt;li&gt;이렇게 점차 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Activity&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;은 분리되어간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;!! 아직 위 코드는 작동하지않는다. 정확히 말하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XML&lt;/code&gt;의 버튼의 onClick이 작동하지 않는다.  다음 솔루션에서 해당 내용을 구현한다.&lt;/p&gt;

&lt;h4 id=&quot;solutionactivity3kt&quot;&gt;SolutionActivity3.kt&lt;/h4&gt;
&lt;p&gt;새로운 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;을 생성한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SimpleViewModelSolution  

class SimpleViewModelSolution : ViewModel() {
    private val _name = MutableLiveData(&quot;Ada&quot;)
    private val _lastName = MutableLiveData(&quot;Lovelace&quot;)
    private val _likes =  MutableLiveData(0)

    val name: LiveData&amp;lt;String&amp;gt; = _name
    val lastName: LiveData&amp;lt;String&amp;gt; = _lastName
    val likes: LiveData&amp;lt;Int&amp;gt; = _likes

    // popularity is exposed as LiveData using a Transformation instead of a @Bindable property.
    val popularity: LiveData&amp;lt;Popularity&amp;gt; = Transformations.map(_likes) {
        when {
            it &amp;gt; 9 -&amp;gt; Popularity.STAR
            it &amp;gt; 4 -&amp;gt; Popularity.POPULAR
            else -&amp;gt; Popularity.NORMAL
        }
    }

    fun onLike() {
        _likes.value = (_likes.value ?: 0) + 1
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;_name, _lastName, , _likes가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MutableLiveData&lt;/code&gt;로 선언되었다.
    &lt;ul&gt;
      &lt;li&gt;이는 변환할 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;를 의미한다.
        &lt;ul&gt;
          &lt;li&gt;이 변수를 name, lastName, likes 라는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LivdData&amp;lt;&amp;gt;&lt;/code&gt; 변수에 입력한다.&lt;/li&gt;
          &lt;li&gt;해당 매커니즘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LivdData&amp;lt;&amp;gt;&lt;/code&gt;의 변화를 읽고 UI를 업데이트 할 수 있도록 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;popopularity enum 변수도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&amp;lt;&amp;gt;&lt;/code&gt;로 설정하여 변화를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;내부에서 변화를 감지한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;!! &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&amp;lt;&amp;gt;&lt;/code&gt;는 UI 컨트롤러의 수명주기를 인식하여 관찰하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataBinding&lt;/code&gt;이 사용된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XML&lt;/code&gt;의 수명주기 소유자를 지정해야한다. 다음과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Activity&lt;/code&gt;를 수정한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SolutionActivity3 : AppCompatActivity() {

    private val viewModel by lazy { ViewModelProvider(this).get(SimpleViewModelSolution::class.java) }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        val binding: ActivitySolution3Binding =
            DataBindingUtil.setContentView(this, R.layout.activity_solution3)

        binding.lifecycleOwner = this

        binding.viewmodel = viewModel
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binding.lifecycleOwner&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;binding 된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xml&lt;/code&gt; 레이아웃의 수명주기 소유자가 UI 컨트롤러로 연결된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Activity&lt;/code&gt;임을 나타낸다.
        &lt;ul&gt;
          &lt;li&gt;이로써 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&amp;lt;&amp;gt;&lt;/code&gt;의 변화를 감지하여 업데이트 할 수 있게 되었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UI 컨트롤러의 코드줄이 확연하게 줄어든 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;solutionactivity4kt&quot;&gt;SolutionActivity4.kt&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataBinding&lt;/code&gt;을 사용하면 거의 모든 UI 호출이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Binding Adapter&lt;/code&gt;라는 정적인 방법으로 이루어진다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Room&lt;/code&gt;은 엄청냔 앙의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Binding Adapter&lt;/code&gt;를 제공한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Android:text&lt;/code&gt; 속성의 예는 다음과 같다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     @BindingAdapter(&quot;android:text&quot;)
 public static void setText(TextView view, CharSequence text) {
     // Some checks removed for clarity

     view.setText(text);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Background&lt;/code&gt; 속성은 다음과 같다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      @BindingAdapter(&quot;android:background&quot;)
  public static void setBackground(View view, Drawable drawable) {
      if (VERSION.SDK_INT &amp;gt;= VERSION_CODES.JELLY_BEAN) {
          view.setBackground(drawable);
      } else {
          view.setBackgroundDrawable(drawable);
      }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Binding Adapter&lt;/code&gt;를 사용하여 다음과 같은 Progress bar를 생성해 보자.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // util/BindingAdapters.kt
	
      @BindingAdapter(&quot;app:hideIfZero&quot;)
  fun hideIfZero(view: View, number: Int) {
      view.visibility = if (number == 0) View.GONE else View.VISIBLE
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;첫번째 파라미터가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View&lt;/code&gt;이므로 모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View&lt;/code&gt;에서 사용할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;해당 타입을 변경하여 특정 클래스로 제한할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레이아웃의 반환을 구분하기 위해 정수를 파라미터로 받는다.
    &lt;ul&gt;
      &lt;li&gt;0인경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View.GONE&lt;/code&gt;이 되어 보이지 않는다.
        &lt;ul&gt;
          &lt;li&gt;아닌경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View.VISBLE&lt;/code&gt;이 되어 표시된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;activity_solution.xml&lt;/code&gt;에서 진행 Progress bar를 찾아 해당 어댑터를 추가한다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &amp;lt;ProgressBar
          android:id=&quot;@+id/progressBar&quot;
          app:hideIfZero=&quot;@{viewmodel.likes}&quot;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;이제 Progress bar는 좋아요 숫자인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewmodel.likes&lt;/code&gt;의 상태에 따라서 보여지거나 안보여지게 설정 되었다.&lt;/li&gt;
  &lt;li&gt;이제 Progress bar가 특정 좋아요 숫자에 따라 색상이 채워지도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Binding Adapter&lt;/code&gt;를 만들어보자.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@BindingAdapter(value = [&quot;app:progressScaled&quot;, &quot;android:max&quot;], requireAll = true)
fun setProgress(progressBar: ProgressBar, likes: Int, max: Int) {
  progressBar.progress = (likes * max / 5).coerceAtMost(max)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;해당 어댑터는 파라미터가 누락된 경우 사용되지 않는다.&lt;/li&gt;
  &lt;li&gt;어댑터는 컴파일 시간에 동작한다.&lt;/li&gt;
  &lt;li&gt;모든 요소가 다음과같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XML&lt;/code&gt;에 존재해야 한다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &amp;lt;ProgressBar
              android:id=&quot;@+id/progressBar&quot;
              app:hideIfZero=&quot;@{viewmodel.likes}&quot;
              app:progressScaled=&quot;@{viewmodel.likes}&quot;
              android:max=&quot;@{100}&quot;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;앱을 실행하면 Progress bar 가 어떻게 채워지는지 알 수 있다.
    &lt;ul&gt;
      &lt;li&gt;다만 아직 색상이 변경되지는 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;마지막 솔루션을 통해 모든 동작을 완성해보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;solutionactivity5kt&quot;&gt;SolutionActivity5.kt&lt;/h4&gt;
&lt;p&gt;likes 값에 따라 Progress bar 표시줄의 색상을 색칠하고 속성을 추가하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Binding Adapter&lt;/code&gt;  과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XML&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@BindingAdapter(&quot;app:progressTint&quot;)
fun tintPopularity(view: ProgressBar, popularity: Popularity) {

    val color = getAssociatedColor(popularity, view.context)

    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.LOLLIPOP) {
        view.progressTintList = ColorStateList.valueOf(color)
    }
}

...

private fun getAssociatedColor(popularity: Popularity, context: Context): Int {
    return when (popularity) {
        Popularity.NORMAL -&amp;gt; context.theme.obtainStyledAttributes(
            intArrayOf(android.R.attr.colorForeground)
        ).getColor(0, 0x000000)
        Popularity.POPULAR -&amp;gt; ContextCompat.getColor(context, R.color.popular)
        Popularity.STAR -&amp;gt; ContextCompat.getColor(context, R.color.star)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// XML 
...
        &amp;lt;ProgressBar
                android:id=&quot;@+id/progressBar&quot;
                app:hideIfZero=&quot;@{viewmodel.likes}&quot;
                app:progressScaled=&quot;@{viewmodel.likes}&quot;
                app:progressTint=&quot;@{viewmodel.popularity}&quot;
                android:max=&quot;@{100}&quot;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Binding Adpater&lt;/code&gt;인 progressTint에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewmodel.popularity&lt;/code&gt;를 바인딩하고있다.
    &lt;ul&gt;
      &lt;li&gt;입력되는 popularity enum type에 따라서 getAssociatedColor 메소드를 통해 색상이 지정된다.
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XML&lt;/code&gt; 내부의 progress bar view에서 해당 어댑터&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app:progressTint&lt;/code&gt;를 통해 업데이트 하여 뿌려준다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;likes에 따라 다른 아이콘을 표시하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Binding Adpater&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XML&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@BindingAdapter(&quot;app:popularityIcon&quot;)
fun popularityIcon(view: ImageView, popularity: Popularity) {

    val color = getAssociatedColor(popularity, view.context)

    ImageViewCompat.setImageTintList(view, ColorStateList.valueOf(color))

    view.setImageDrawable(getDrawablePopularity(popularity, view.context))
}

...

private fun getDrawablePopularity(popularity: Popularity, context: Context): Drawable? {
    return when (popularity) {
        Popularity.NORMAL -&amp;gt; {
            ContextCompat.getDrawable(context, R.drawable.ic_person_black_96dp)
        }
        Popularity.POPULAR -&amp;gt; {
            ContextCompat.getDrawable(context, R.drawable.ic_whatshot_black_96dp)
        }
        Popularity.STAR -&amp;gt; {
            ContextCompat.getDrawable(context, R.drawable.ic_whatshot_black_96dp)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// XML

&amp;lt;ImageView
android:id=&quot;@+id/imageView&quot;
app:popularityIcon=&quot;@{viewmodel.popularity}&quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Binding Adapter&lt;/code&gt;인 popularityIcon에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewmodel.popularity&lt;/code&gt;를 바인딩하고있다.
    &lt;ul&gt;
      &lt;li&gt;입력되는 popularity enum type에 따라서 getDrawablePopularity 메소드를 통해 이미지가 지정된다.
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XML&lt;/code&gt; 내부의 progress bar view에서 해당 어댑터&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app:popularityIcon&lt;/code&gt;을 통해 업데이트 하여 뿌려준다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hun</name></author><category term="Kotlin" /><category term="MVVM" /><category term="AndroidUI" /><summary type="html"></summary></entry><entry><title type="html">Architecture Components Example - Room, LiveData, ViewModel</title><link href="http://localhost:4000/android-kotlin/implementing-mvvm-android-livedata/" rel="alternate" type="text/html" title="Architecture Components Example - Room, LiveData, ViewModel" /><published>2020-10-23T00:00:00+09:00</published><updated>2020-10-23T00:00:00+09:00</updated><id>http://localhost:4000/android-kotlin/implementing-mvvm-android-livedata</id><content type="html" xml:base="http://localhost:4000/android-kotlin/implementing-mvvm-android-livedata/">&lt;h2 id=&quot;architecture-component&quot;&gt;Architecture Component&lt;/h2&gt;
&lt;p float=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/gif/2020-10-2318-56.gif&quot; width=&quot;300&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Architecture Component 예제를 공부하면서 주요 기능으로 자리잡고 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Room&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;, 에 대하여 정리한 글이다.&lt;/p&gt;

&lt;p float=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/png/architectureComponent.png&quot; width=&quot;100%&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;이미지 출처 및 참고자료 &lt;br /&gt;
&lt;a href=&quot;https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin?hl=ko#1&quot;&gt;https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin?hl=ko#1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;공식문서
&lt;a href=&quot;import androidx.lifecycle.viewModelScope&quot;&gt;Room&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/livedata?hl=ko&quot;&gt;LiveData&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/viewmodel?hl=ko&quot;&gt;ViewModel&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;room&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Room&lt;/code&gt;?&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Room&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQLite&lt;/code&gt; 추상화 레이어를 제공하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQLite&lt;/code&gt;를 완벽히 활용하면서 더 견고한 데이터 베이스 액세스를 가능하게 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SQLite&lt;/code&gt; 데이터베이스 위에 있는 데이터베이스 계층이다.&lt;/li&gt;
  &lt;li&gt;SQLiteOpenHelper로 처리하던 작업을 처리한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAO&lt;/code&gt;를 사용하여 데이터베이스에 쿼리를 발급한다.&lt;/li&gt;
  &lt;li&gt;성능저하를 피하기 위해 main thread 에서 Query를 사용하는 것을 허용하지 않는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Room&lt;/code&gt;에서 LiveData를 반환하면 백그라운드 스레드에서 Query 비동기로 자동실행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//bulid.gradle

implementation &quot;androidx.room:room-runtime:$rootProject.roomVersion&quot;
kapt &quot;androidx.room:room-compiler:$rootProject.roomVersion&quot;
implementation &quot;androidx.room:room-ktx:$rootProject.roomVersion&quot;
androidTestImplementation &quot;androidx.room:room-testing:$rootProject.roomVersion&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;entity&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Entity&lt;/code&gt;&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Word.kt

@Entity(tableName = &quot;word_table&quot;)
data class Word(@PrimaryKey @ColumnInfo(name = &quot;word&quot;) val word: String)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@Entity(tableName =””)
    &lt;ul&gt;
      &lt;li&gt;SQLite table&lt;/li&gt;
      &lt;li&gt;table name을 설정한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;@PrimaryKey
    &lt;ul&gt;
      &lt;li&gt;모든 entity 는 primary key가 있어야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;@ColumnInfo -&amp;gt; column 이름을 설정하고 유형을 지정한다.&lt;/li&gt;
  &lt;li&gt;데이터베이스에 저장된 모든 속성은 public 이며 kotlin의 기본 설정이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;dao&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAO&lt;/code&gt;&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//WordDao.kt

@Dao
interface WordDao {

    @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)
    fun getAlphabetizedWords(): LiveData&amp;lt;List&amp;lt;Word&amp;gt;&amp;gt;

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(word: Word)

    @Query(&quot;DELETE FROM word_table&quot;)
    suspend fun deleteAll()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dao&lt;/code&gt;는 interface혹은 abstract 클래스로 설정해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Dao&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;Room을 위한 DAO 클래스로 식별한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Insert&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;SQL 문법이 필요없는 특별한 DAO 메소드 anottation이다.&lt;/li&gt;
      &lt;li&gt;테이블에 데이터를 추가하는 용도&lt;/li&gt;
      &lt;li&gt;동일하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Update&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Delete&lt;/code&gt;도 제공된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OnConflictStrategy.IGNORE&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;입력된 값이 테이블에 있는 값과 동일하면 작업을 무시한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;deleteAll()
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Delete&lt;/code&gt;는 여러개의 entitiy 삭제할 수 없기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Query&lt;/code&gt;로 직접 구현해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Query&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Query&lt;/code&gt;는 string parameter로 되어있는 SQL을 입력받고 실행하는 annotation이다.&lt;/li&gt;
      &lt;li&gt;구현을 위해 SQLite 문법을 이해하고 있어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;roomdatabase&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RoomDatabase&lt;/code&gt;&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//WordRoomDatabase.kt


@Database(entities = [Word::class], version = 1, exportSchema = false)
abstract class WordRoomDatabase : RoomDatabase() {

    // The database exposes DAOs through an abstract 'getter' method for each @Dao.
    abstract fun wordDao(): WordDao
		
		. . .
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Room&lt;/code&gt;클래스는 abstract로 선언해야 하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RoomDatabase&lt;/code&gt;객체를 상속받아야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Database&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Entity&lt;/code&gt;와 version을 입력받아 데이터베이스를 셋팅한다.&lt;/li&gt;
      &lt;li&gt;각각의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Entity&lt;/code&gt;는 데이터베이스에 작성 될 테이블에 해당한다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exportSchema&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;데이터베이스 마이그레이션은 코드의 범위를 벗어나므로 빌드 경고를 피하기 위해 여기서 exportSchema를 false로 설정해야한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;database schema가 변경될 경우 version number를 업데이트하고 migration을 관리해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wordDao()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;데이터베이스는 각각의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAO&lt;/code&gt;에 대해 abstract getter 방법으로 제공한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;. . .
abstract fun wordDao(): WordDao

private class WordDatabaseCallback(
    private val scope: CoroutineScope
) : RoomDatabase.Callback() {

    override fun onOpen(db: SupportSQLiteDatabase) {
        super.onOpen(db)
        WordRoomDatabase.INSTANCE?.let { database -&amp;gt;
            scope.launch {
                var wordDao = database.wordDao()

                // Delete all content here.
                wordDao.deleteAll()

                // Add sample words.
                var word = Word(&quot;Hello&quot;)
                wordDao.insert(word)
                word = Word(&quot;World!&quot;)
                wordDao.insert(word)

                // TODO: Add your own words!
                word = Word(&quot;TODO!&quot;)
                wordDao.insert(word)
            }
        }
    }
}
. . .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;WordDatabase 인스턴스가 생성될 때 실행될 callback 함수이다.&lt;/li&gt;
  &lt;li&gt;scope: CoroutineScope
    &lt;ul&gt;
      &lt;li&gt;Room의 Query는 main Thread에서 사용할 수 없다.
        &lt;ul&gt;
          &lt;li&gt;다른 Thread를 사용하기 위해 CoroutineScope를 입력받아 사용한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;wordDao의 동작
    &lt;ul&gt;
      &lt;li&gt;deleteAll() -&amp;gt; entity를 모두 지운다.&lt;/li&gt;
      &lt;li&gt;insert() -&amp;gt; “Hello”, “World!”, “Todo” 3가지 객체를 생성하고 insert 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실제 데이터베이스에서 entity가 초기화 되어야 하거나 꼭 있어야하는 데이터가 있을 경우 위 방법을 통해 구현한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;. . .
companion object {
    @Volatile
    private var INSTANCE: WordRoomDatabase? = null

    fun getDatabase(
        context: Context,
        scope: CoroutineScope
    ): WordRoomDatabase {
        // if the INSTANCE is not null, then return it,
        // if it is, then create the database
        return INSTANCE ?: synchronized(this) {
            val instance = Room.databaseBuilder(
                context.applicationContext,
                WordRoomDatabase::class.java,
                &quot;word_database&quot;
            )
                .addCallback(WordRoomDatabase.WordDatabaseCallback(scope))
                .build()
            INSTANCE = instance
            // return instance
            instance
        }
    }
}
. . .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getDatabase()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 메소드를 통해 Database 객체를 싱글턴으로 반환한다.&lt;/li&gt;
      &lt;li&gt;context와 callback 함수 실행을 위해 CoroutinScope를 입력받는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Room.databaseBuilder()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;응용 프로그램 context에서 RoomDatabase 객체를 생성한다.&lt;/li&gt;
      &lt;li&gt;context, Roomdatabase, database name을 입력받는다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addCallback()&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;bulid 전 콜백함수를 실행하여 데이터를 초기화한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bulid()&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;마지막으로 빌드하고 instance를 반환한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;repository-&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt; ?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt;는 여러 데이터 소스에 대한 액세스를 추상화한다.&lt;/li&gt;
  &lt;li&gt;아키텍처 구성요소 라이브러리에 속하지 않지만 코드 분리 및 아키텍처를 위한 권장 모범 사례다.&lt;/li&gt;
  &lt;li&gt;애플리케이션의 나머지 부분에 대한 데이터 액세스를 위한 API를 제공한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt;를 사용하는 이유
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Qeury&lt;/code&gt;를 관리하고 여러 백엔드를 사용할 수 있도록 허용한다.&lt;/li&gt;
      &lt;li&gt;Network와 Local 데이터베이스 사이에서 캐시된 결과를 어떻게 사용할지를 결정하기위한 로직을 구현한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// WordRepository.kt

class WordRepository(private val wordDao:WordDao) {

    val allWords: LiveData&amp;lt;List&amp;lt;Word&amp;gt;&amp;gt; = wordDao.getAlphabetizedWords()

    suspend fun insert(word: Word) {
        wordDao.insert(word)
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAO&lt;/code&gt;를 private으로 생성함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAO&lt;/code&gt;에 대한 액세스만 필요하므로 전체 데이터베이스 대신 DAO를 전달한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Room&lt;/code&gt;은 별도의 쓰레드에서 모든 쿼리를 실행한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Room&lt;/code&gt;+ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAO&lt;/code&gt; 로 검색된 객체가 LiveData&amp;lt;&amp;gt;로 입력된다.
    &lt;ul&gt;
      &lt;li&gt;관찰된 LiveData는 변경 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observer&lt;/code&gt;에 통지한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suspend fun insert()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;suspend 를 붙임으로서 코루틴으로 언제든 지연되었다가 재개 될 수 있는 메소드가 정의된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;livedata&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;?&lt;/h2&gt;
&lt;p&gt;데이터가 변경될 때 반응하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View&lt;/code&gt;가 있다고 가정했을 때 데이터가 어떻게 저장되느냐에 따라 이것이 까다로울 수 있다. 앱의 여러가지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;View&lt;/code&gt;에서 데이터 변경을 관찰하다 보면 코드줄이 길어지고 찾기 힘들어지면서 Test와 디버깅을 어렵게 만든다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;는 이러한 문제를 해결한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;식별 가능한 데이터 홀더 클래스&lt;/li&gt;
  &lt;li&gt;일반 클래스와 달리 수명주기를 인식함&lt;/li&gt;
  &lt;li&gt;activity, fragment, service등의 앱 구성요소 수명주기를 고려함&lt;/li&gt;
  &lt;li&gt;수명주기 인식을 통해 활성상태에 있는 앱 구성요소의 관찰자만 업데이트 함&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;참고:
LiveData를 Room과 독립적으로 사용할 경우 데이터 업데이트를 관리해야한다. 
LiveData에는 저장된 데이터를 업데이트하는 데에 대한 공식적은 방법이 없다. 

LiveData 저장된 데이터를 업데이트 하려면 MutableLiveData를 사용해야한다. 
method -&amp;gt; setValue(T), postValue(T)
일반적으로 MutableLiveData는 ViewModel 내에서 사용된다.
ViewModel은 immutable LiveData 객체만 Observers에게 노출시킨다. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;다음은 안드로이드 공식문서에 나와있는 LiveData의 장점이다.&lt;/p&gt;
&lt;h5 id=&quot;livedata의-장점&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;의 장점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;UI와 데이터 상태의 일치 보장
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;는 수명주기 상태가 변경될 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observer&lt;/code&gt; 객체에 알림&lt;/li&gt;
      &lt;li&gt;코드를 통합하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observer&lt;/code&gt;객체에 UI를 업데이트&lt;/li&gt;
      &lt;li&gt;데이터가 변경될 때마다 관찰자가 UI를 업데이트 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메모리누출 없음
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lifecylce&lt;/code&gt; 객체와 관찰자가 결합되어 있고 수명주기가 끝나면 자동 삭제됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;중지된 activity로 인한 비정상 종료가 없음
    &lt;ul&gt;
      &lt;li&gt;관찰자의 수명주기가 비활성 상태이면 관찰자는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; 이벤트를 수신하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수명주기를 수동으로 처리하지 않음
    &lt;ul&gt;
      &lt;li&gt;UI 구성요소는 관련 데이터를 관찰하기만 할 뿐 관찰을 중지하거나 다시 시작하지 않음&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;는 관찰하는 동안 관련 수명주기 상태의 변경을 인식하여 자동으로 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최신 데이터 유지
    &lt;ul&gt;
      &lt;li&gt;수명 주기가 비활성화 되고 다시 활성화 될 때 최신 데이터를 수신&lt;/li&gt;
      &lt;li&gt;ex) 백그라운드에 있던 activity가 포그라운드로 돌아온 직후 최신 데이터 수신&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;적절한 구성 변경
    &lt;ul&gt;
      &lt;li&gt;구성 변경(ex-&amp;gt;기기회전)으로 인해 activity, fragment 등이 다시 생성되면 사용할 수 있는 최신정보 를 즉시수신&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리소스 공유
    &lt;ul&gt;
      &lt;li&gt;맵에서 시스템 서비스를 공유할 수 있도록 싱글톤 패턴을 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; 객체를 확장하여 시스템 서비스를 래핑&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; 객체가 시스템 서비스에 한 번 연결되면 리소스가 필요한 모든 관찰자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; 객체를 볼 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;viewmodel&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;클래스는 수명주기를 고려하여 UI 관련 데이터를 저장하고 관리하도록 설계되었다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt; 클래스를 사용하면 화면 회전과 같이 구성을 변경할 때도 데이터를 유지할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;이 없는경우
    &lt;ul&gt;
      &lt;li&gt;Android 프레임워크는 UI Controller(activity,fragment..) 의 수명주기를 관리한다. 프레임워크는 특정 사용자 작업이나 완전히 통제할 수 없는 기기 이벤트에 대한 응답으로 UI 컨트롤러를 제거하거나 다시 만들도록 결정할 수 있다. 이러한 경우 컨트롤러에 저장된 일시적은 모든 UI 관련데이터가 손실된다.&lt;/li&gt;
      &lt;li&gt;예를들어 activity의 view 구성의 변경을 위해 다시 생성하면 새 activity는 새로운 데이터를 처음부터 다시 가져와야 한다. 간단한 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onSaveInstanceState()&lt;/code&gt;메소드를 통해 복원할 수 있으나 이 경우는 소량의 데이터에만 적합하다.&lt;/li&gt;
      &lt;li&gt;UI 컨트롤러가 비동기 호출을 자주 해야한다.
        &lt;ul&gt;
          &lt;li&gt;이는 비동기 호출관리, 메모리누출 방지, 시스템에서 호출 폐기 후 호출을 하는지 확인해야한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ui컨트롤러는 주로 ui 데이터를 표시하거나, 사용자 작업에 반응하거나, 권한요청과 같은 커뮤니케이션을 처리하기 위한 것이다. 여기에 데이터베이스나 네트워크 데이터 로드를 담당하도록 요구하면 클래스가 팽창한다. 이는 테스트를 어렵게 만든다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;은 UI 컨트롤러에서 뷰 데이터 소유권을 분리하는 방법을 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// WordViewModel.kt

class WordViewModel(application: Application) : AndroidViewModel(application) {

    private val repository: WordRepository

    val allWords: LiveData&amp;lt;List&amp;lt;Word&amp;gt;&amp;gt;

    init {
        val wordsDao = WordRoomDatabase.getDatabase(application, viewModelScope).wordDao()
        repository = WordRepository(wordsDao)
        allWords = repository.allWords
    }

    fun insert(word: Word) = viewModelScope.launch(Dispatchers.IO) {
        repository.insert(word)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Application&lt;/code&gt;을 파라미터로 받고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AndroidViewModel&lt;/code&gt;을 상속받는다.&lt;/li&gt;
  &lt;li&gt;init block을 사용하여 인스턴스 생성 시 해야할 로직을 구현한다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WordRoomDatabase&lt;/code&gt;를 생성하고 Dao 객체를 가져온다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WordRepository&lt;/code&gt;에 가져온 dao 를 입력하여 인스턴스를 생성한다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allWords&lt;/code&gt;에 repository 내부에서 변화를 관찰하고 있는 allWords를 입력한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;insert(word: Word)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;ui 컨트롤러에서 호출하여 사용한다.&lt;/li&gt;
      &lt;li&gt;데이터에 관련된 로직은 viewModel이 담당하고 ui 컨트롤러는 단지 데이터 입력 후 전달만을 담당하게 된다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewModelScope&lt;/code&gt;를 사용하여 코루틴을 구현한다.
        &lt;ul&gt;
          &lt;li&gt;위에서 생성된 repository내부의 insert() 메소드를 통해 Word 데이터를 추가한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;ui-controller의-viewmodel&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UI Controller&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;&lt;/h5&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ArchiTecturecomponentActivity.kt 

...
private lateinit var wordViewModel: WordViewModel

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_architecture_component)
		
		...

    wordViewModel = ViewModelProvider(this).get(WordViewModel::class.java)
    wordViewModel.allWords.observe(this, Observer { words -&amp;gt;
        // Update the cached copy of the words in the adapter.
        words?.let { adapter.setWords(it) }
    })

		...
}
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModelProvider(this).get(WordViewModel::class.java)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;인스턴스 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wordViewModel.allWords.observe{}&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt; 내부의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allWords&lt;/code&gt; 객체를  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;observe{}&lt;/code&gt; 통해 관찰한다.
        &lt;ul&gt;
          &lt;li&gt;관찰하고 있다가 변동이 발생한 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apdater.setWords(it)&lt;/code&gt;로 객체를 전달한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// WordListAdapter.kt
...

    override fun onBindViewHolder(holder: WordViewHolder, position: Int) {
        val current = words[position]
        holder.wordItemView.text = current.word
    }

    internal fun setWords(words: List&amp;lt;Word&amp;gt;) {
        this.words = words
        notifyDataSetChanged()
    }
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Activity&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewModel&lt;/code&gt;을 통해 관찰하고있던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allWords&lt;/code&gt;가 이곳에 전달된다.
    &lt;ul&gt;
      &lt;li&gt;전달되었다는 뜻은 변경되었다는 것을 의미한다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;notifiDataSetChanged()&lt;/code&gt;메소드로 변경되었음을 알린다.
        &lt;ul&gt;
          &lt;li&gt;그렇게 되면 adpater 내부에서 자동으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onBindViewHolder&lt;/code&gt; 를 호출한다.
            &lt;ul&gt;
              &lt;li&gt;재정비 된 words 에서 변경된 내용이 업데이트 된다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다시한번 아래 이미지를 보며서 정리해보자.&lt;/p&gt;

&lt;p float=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/png/architectureComponent.png&quot; width=&quot;100%&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;다시보니 ViewModel에서 UI 컨트롤러에 변동사항을 알리는것을 제외하곤  화살표의 방향이 아래로만 되어있는것이 눈에 들어온다.  이러한 flow가 생겨난 이유는 UI 컨트롤러에서 view를 표시하고 사용자 행동에 반응하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UI Control&lt;/code&gt; 이외의 작업이 추가되어 팽창하는것을 막기 위함이다.  여기서 이외의 작업을 담당하기위해 분리 된 것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;이다. 여기서 중요한것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UI Controller&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;를 생성하고 접근하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UI Controller&lt;/code&gt;의 존재를 알지 못하여 직접적으로 접근할 수 없다는 것이다. 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;은 수명주기를 고려하여 UI관련 데이터를 관리한다. 그리고 데이터베이스에서 데이터를 crud하는 작업을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Repository&lt;/code&gt;에게 일임한다. 이렇게 완벽히 분리된 상태에서 변동된 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UI Controller&lt;/code&gt;에 전달하기 위해 존재하는 것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UI Controller&lt;/code&gt;의 수명주기를 알고있으며 관리를 하기로한 객체에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Observer&lt;/code&gt;를 두고 변동을 감지한다.&lt;/p&gt;</content><author><name>Hun</name></author><category term="android-kotlin" /><category term="Kotlin" /><category term="MVVM" /><summary type="html">Architecture Component</summary></entry><entry><title type="html">android snackbar &amp;amp; move to activity in fragment</title><link href="http://localhost:4000/android-ui/android-snackbar-move-to-activity-in-fragment/" rel="alternate" type="text/html" title="android snackbar &amp;amp; move to activity in fragment" /><published>2020-10-22T00:00:00+09:00</published><updated>2020-10-22T00:00:00+09:00</updated><id>http://localhost:4000/android-ui/android-snackbar-move-to-activity-in-fragment</id><content type="html" xml:base="http://localhost:4000/android-ui/android-snackbar-move-to-activity-in-fragment/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&quot;&gt;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/training/snackbar/action?hl=ko&quot;&gt;https://developer.android.com/training/snackbar/action?hl=ko&lt;/a&gt;&lt;/p&gt;

&lt;p float=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/gif/2020-10-2216-28.gif&quot; width=&quot;300&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;utilviewextkt&quot;&gt;util/ViewExt.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun View.showSnackbar(snackbarText: String, timeLength: Int) {
    Snackbar.make(this, snackbarText, timeLength).run {
        addCallback(object : Snackbar.Callback() {
            override fun onShown(sb: Snackbar?) {
                EspressoIdlingResource.increment()
            }
    
            override fun onDismissed(transientBottomBar: Snackbar?, event: Int) {
                EspressoIdlingResource.decrement()
            }
        })
        show()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;snackbar는 위 예제 gif에서 login 선택 시 아래에 등장하는 메시지 이다.&lt;/li&gt;
  &lt;li&gt;Toast와 함께 안드로이드에서 제공하는 기능이다 .&lt;/li&gt;
  &lt;li&gt;매번 Snackbar.make()로 필요한 곳에서 구현해도 문제는 없다.
    &lt;ul&gt;
      &lt;li&gt;ui test를 위한 EspressoIdlingResource 를 셋팅해야 하기 때문에 코드가 길어진다.
        &lt;ul&gt;
          &lt;li&gt;프로젝트 전역에서 손쉽게 사용하기 위해 ViewExt.kt 를 만들고 그안에 함수만 구현해 두는 방식이다.&lt;/li&gt;
          &lt;li&gt;showSnackbar(“Hello”, Snackbar.LENGTH_SHORT) 처럼 메시지와 표시될 시간만 지정해 두어 코드 길이를 줄일 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;View.showSnackbar 로 등록되기 때문에 어느곳에서든 view를 가지고있다면 호출하여 사용 가능하다.
    &lt;h2 id=&quot;introswipefragmentkt&quot;&gt;IntroSwipeFragment.kt&lt;/h2&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...

 MotionEvent.ACTION_UP -&amp;gt; {
                  when {
                      button.y &amp;lt; (parentHeight * 0.1f) - status -&amp;gt; {
                          button.visibility = View.GONE
                          view?.showSnackbar(&quot;Coming soon ...&quot;, Snackbar.LENGTH_SHORT)
                      }
            
                      button.y &amp;gt; (parentHeight * 0.9f) - status -&amp;gt; {
                          val intent = Intent(activity, MainActivity::class.java)
                          startActivity(intent)
                          activity?.overridePendingTransition(R.anim.fadein, R.anim.fadeout)
                          activity?.supportFragmentManager?.beginTransaction()?.remove(this)
                              ?.commit()
                          activity?.finish()
                      }
                  }
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;표시되는 순간이 중앙 로고를 스와이프 하여 Login 텍스트에 가져다 놯을때이다.
    &lt;ul&gt;
      &lt;li&gt;위에 선언한 메소드를 fragment 내부의 view를 통해 호출하여 사용가능하다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;view?.showSnackbar(&quot;Comming soon ...&quot;, Snackbar.LENGTH_SHORT)&lt;/code&gt; 와 같이 한줄로 snackbar 구현이 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;activity가 전환되는 부분은 로고를 스와이프 하여 GUEST 텍스트에 가져다 놯을 때이다.
    &lt;ul&gt;
      &lt;li&gt;Intent를 사용해 activity 전환 로직을 구현한다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;activity?.supportFragmentManager?.beginTransaction()?.remove(this)?.commit()&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;guset text에 중앙로고를 가져돠 놓고 액티비티가 전환되는 과정에서 애니메이션 효과를 넣었다.&lt;/li&gt;
          &lt;li&gt;약간의 딜레이가 생기기 때문에 중앙로고가 다시 표시되기 때문에 activity를 통해 현재 프래그먼트 자체를 없애는 로직이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hun</name></author><category term="android-ui" /><category term="AndroidUI" /><category term="Kotlin" /><summary type="html">참고자료 https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin https://developer.android.com/training/snackbar/action?hl=ko</summary></entry><entry><title type="html">android swipe - 터치 좌표를 따라서 view 이동하기</title><link href="http://localhost:4000/android-ui/android-swipe-view/" rel="alternate" type="text/html" title="android swipe - 터치 좌표를 따라서 view 이동하기" /><published>2020-10-21T00:00:00+09:00</published><updated>2020-10-21T00:00:00+09:00</updated><id>http://localhost:4000/android-ui/android-swipe-view</id><content type="html" xml:base="http://localhost:4000/android-ui/android-swipe-view/">&lt;p&gt;참고자료
&lt;a href=&quot;https://sunghyun1038.tistory.com/24&quot;&gt;https://sunghyun1038.tistory.com/24&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/training/gestures/viewgroup?hl=ko&quot;&gt;https://developer.android.com/training/gestures/viewgroup?hl=ko&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/guide/topics/graphics/prop-animation?hl=ko&quot;&gt;https://developer.android.com/guide/topics/graphics/prop-animation?hl=ko&lt;/a&gt;&lt;/p&gt;

&lt;p float=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/gif/2020-10-2200-42.gif&quot; width=&quot;300&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;fragment_main_swipexml&quot;&gt;fragment_main_swipe.xml&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/intro_cl&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&amp;gt;

    &amp;lt;TextView
        style=&quot;@style/Text.RankStyle&quot;
        android:id=&quot;@+id/intro_login_text&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;@string/login&quot;
        android:textSize=&quot;20sp&quot;
        android:visibility=&quot;gone&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt;

    &amp;lt;com.airbnb.lottie.LottieAnimationView
        android:id=&quot;@+id/intro_swipe_up&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginStart=&quot;10dp&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot;
        app:layout_constraintBottom_toTopOf=&quot;@+id/intro_logo&quot;
        app:lottie_autoPlay=&quot;true&quot;
        app:lottie_loop=&quot;true&quot;
        app:lottie_rawRes=&quot;@raw/main_swipe_up&quot;/&amp;gt;

    &amp;lt;com.airbnb.lottie.LottieAnimationView
        android:id=&quot;@+id/intro_cursor&quot;
        android:layout_width=&quot;200dp&quot;
        android:layout_height=&quot;200dp&quot;
        android:layout_marginTop=&quot;30dp&quot;
        app:layout_constraintBottom_toBottomOf=&quot;@id/intro_logo&quot;
        app:layout_constraintLeft_toLeftOf=&quot;@id/intro_logo&quot;
        app:layout_constraintRight_toRightOf=&quot;@id/intro_logo&quot;
        app:layout_constraintTop_toTopOf=&quot;@id/intro_logo&quot;
        app:lottie_autoPlay=&quot;true&quot;
        app:lottie_loop=&quot;true&quot;
        app:lottie_rawRes=&quot;@raw/main_cursor&quot; /&amp;gt;

    &amp;lt;TextView
        android:id=&quot;@+id/intro_logo&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;@string/app_name&quot;
        android:textSize=&quot;30sp&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot;
        style=&quot;@style/Text.TitleStyle&quot;/&amp;gt;

    &amp;lt;com.airbnb.lottie.LottieAnimationView
        android:id=&quot;@+id/intro_swipe_down&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginEnd=&quot;10dp&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintTop_toBottomOf=&quot;@+id/intro_logo&quot;
        app:lottie_autoPlay=&quot;true&quot;
        app:lottie_loop=&quot;true&quot;
        app:lottie_rawRes=&quot;@raw/main_swipe_down&quot;/&amp;gt;

    &amp;lt;TextView
        style=&quot;@style/Text.RankStyle&quot;
        android:id=&quot;@+id/intro_guest_text&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;@string/guest&quot;
        android:textSize=&quot;20sp&quot;
        android:visibility=&quot;gone&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&amp;gt;
&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Constraintlayout =&amp;gt; parent layout
    &lt;ul&gt;
      &lt;li&gt;intro_login_text: TextView =&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOGIN&lt;/code&gt; text
        &lt;ul&gt;
          &lt;li&gt;visibility=gone  =&amp;gt; 처음엔 렌더링되지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;intro_swipe_up: LottieAnimation =&amp;gt; 중앙로고 클릭 시 위로 향하는 화살표 애니메이션&lt;/li&gt;
      &lt;li&gt;intro_cursr: LottieAnimation =&amp;gt; 로고 아래에 클릭을 유도하는 손모양 애니메이션&lt;/li&gt;
      &lt;li&gt;intro_logo : Textview =&amp;gt; 중앙로고&lt;/li&gt;
      &lt;li&gt;intro_swipe_down: LottieAnimation =&amp;gt; 중앙 로고 클릭 시 아래로 향하는 화살표 애니메이션&lt;/li&gt;
      &lt;li&gt;intro_guest_text: TextView =&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GUEST&lt;/code&gt; text&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mainswipefragmentkt&quot;&gt;MainSwipeFragment.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        
        return inflater.inflate(R.layout.fragment_main_swipe, container, false)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Fragment override 함수&lt;/li&gt;
  &lt;li&gt;inflater를 통해 위에서 생성한 xml 프래그먼트를 입력한다.&lt;/li&gt;
  &lt;li&gt;container는 activity에서 fragment 생성 시 입력받는다.
    &lt;ul&gt;
      &lt;li&gt;container =&amp;gt; 프래그먼트가 표시 될 액티비티&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private lateinit var parentView: ConstraintLayout
    private lateinit var logoSwipeButton: TextView
    private lateinit var loginTextView: TextView
    private lateinit var guestTextView: TextView
    
    private lateinit var cursorAnimation: LottieAnimationView
    private lateinit var swipeUpAnimation: LottieAnimationView
    private lateinit var swipeDownAnimation: LottieAnimationView
		
		...
		
		    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        logoSwipeButton = view.findViewById(R.id.intro_logo)
        cursorAnimation = view.findViewById(R.id.intro_cursor)
        
        swipeUpAnimation = view.findViewById(R.id.intro_swipe_up)
        swipeDownAnimation = view.findViewById(R.id.intro_swipe_down)
        swipeDownAnimation.visibility = View.GONE
        swipeUpAnimation.visibility = View.GONE
        
        parentView = view.findViewById(R.id.intro_cl)
        
        loginTextView = view.findViewById(R.id.intro_login_text)
        guestTextView = view.findViewById(R.id.intro_guest_text)
        
        var statusBarHeight: Int = 0
        var resId = resources.getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;)
        if (resId &amp;gt; 0) {
            statusBarHeight = resources.getDimensionPixelSize(resId)
        }
        
        setOnTouchListener(statusBarHeight)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;lateinit var로 위에서 생성한 각각의 뷰의 타입을 지정한다.
    &lt;ul&gt;
      &lt;li&gt;onView() 함수를 사용하여 view를 넘겨받아 findViewById로 xml내부의 뷰들과 연결한다.&lt;/li&gt;
      &lt;li&gt;swipedown, swipeup 애니메이션은 클릭 시 보여지기 때문에 visibility = gone 으로 설정한다.&lt;/li&gt;
      &lt;li&gt;상태바 크기를 구하는 이유는 중앙 로고를 스와이프로 이동하고 다시 원위치로 돌아갈 때 필요하기 때문이다.
        &lt;ul&gt;
          &lt;li&gt;중앙정렬에서 약간 빗나감&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;setOnTouchListener() 내부에 중앙로고인 logoSwipeButton에 리스너를 연결하여 구현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @SuppressLint(&quot;ClickableViewAccessibility&quot;, &quot;Recycle&quot;, &quot;ResourceAsColor&quot;)
    private fun setOnTouchListener(status: Int) {
        logoSwipeButton.setOnTouchListener { button, event -&amp;gt;
            //var parentWidth = parentView.width
            var parentHeight = parentView.height
            
						when (event!!.action) {
                MotionEvent.ACTION_DOWN -&amp;gt; {
                    cursorAnimation.visibility = View.GONE
                    guestTextView.visibility = View.VISIBLE
                    loginTextView.visibility = View.VISIBLE
                    swipeDownAnimation.visibility = View.VISIBLE
                    swipeUpAnimation.visibility = View.VISIBLE
                    swipeDownAnimation.playAnimation()
                    swipeUpAnimation.playAnimation()
                }
    
                MotionEvent.ACTION_UP -&amp;gt; {
                    button.y = ((parentHeight * 0.5f) - status)
                    button.visibility = View.VISIBLE
                    cursorAnimation.visibility = View.VISIBLE
                    swipeDownAnimation.visibility = View.GONE
                    swipeUpAnimation.visibility = View.GONE
                    guestTextView.visibility = View.GONE
                    loginTextView.visibility = View.GONE
                    guestTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f)
                    loginTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f)
                }
    
                MotionEvent.ACTION_MOVE -&amp;gt; {
                    button.y = button.y + (event.y - (button.height * 0.5f))
                    button.visibility = View.VISIBLE
                    guestTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f)
                    loginTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f)
                    when {
                        button.y &amp;lt; (parentHeight * 0.1f) - status -&amp;gt; {
                            button.visibility = View.GONE
                            loginTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 30f)
                        }
            
                        button.y &amp;gt; (parentHeight * 0.9f) - status -&amp;gt; {
                            button.visibility = View.GONE
                            guestTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 30f)
                        }
            
                        button.y &amp;lt; (parentHeight * 0.45f) - status ||
                                button.y &amp;gt; (parentHeight * 0.55f) - status  -&amp;gt; {
                            swipeUpAnimation.visibility = View.GONE
                            swipeDownAnimation.visibility = View.GONE
                        }
                    }
                }
            }
            true
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;MotionEvent.ACTION_DOWN
    &lt;ul&gt;
      &lt;li&gt;화면에 손가락이 닿는 순간을 의미함&lt;/li&gt;
      &lt;li&gt;눌려지는 순간 보여져야 할 상황이 구현되어 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MotionEvent.ACTION_UP
    &lt;ul&gt;
      &lt;li&gt;화면에서 손가락이 뗴어지는 순가을 의미함&lt;/li&gt;
      &lt;li&gt;변경된 사항들이 원래 위치로 reset 되도록 구현되어 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MotionEvent.ACTION_MOVE
    &lt;ul&gt;
      &lt;li&gt;터치 되어진 상태에서 움직임을 감지하는 모든 순간을 의미함&lt;/li&gt;
      &lt;li&gt;var parentHeight = parentView.height
        &lt;ul&gt;
          &lt;li&gt;현재 최상단 레이아웃의 실제 높이를 구현하고 좌표값을 구함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;button.y = button.y + (event.y - (button.height * 0.5f))
        &lt;ul&gt;
          &lt;li&gt;y축에서 터치된 손가락의 실제 좌표를 구함&lt;/li&gt;
          &lt;li&gt;y축만 구현되어있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;button.y &amp;lt; (parentHeight * 0.1f) - status
        &lt;ul&gt;
          &lt;li&gt;터치된 손가락이 최상단 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOGIN&lt;/code&gt; text 범위에 닿는 순간을 의미함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;button.y &amp;gt; (parentHeight * 0.9f) - status
        &lt;ul&gt;
          &lt;li&gt;터치된 손가락이 최하단 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GUEST&lt;/code&gt; text 범위에 닿는 순간을 의미함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;button.y &amp;lt; (parentHeight * 0.45f) - status&lt;/td&gt;
              &lt;td&gt; &lt;/td&gt;
              &lt;td&gt;button.y &amp;gt; (parentHeight * 0.55f) - status&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;중앙 로고를 기준으로 위 아래로 조금씩 움직였을 때의 범위를 의미함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mainactivitykt&quot;&gt;MainActivity.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        supportFragmentManager.beginTransaction()
            .replace(R.id.contentFrame, MainSwipeFragment())
            .commit()
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;supportFragmentManager =&amp;gt; 프래그먼트 생성&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hun</name></author><category term="android-ui" /><category term="AndroidUI" /><category term="AnroidAnimation" /><summary type="html">참고자료 https://sunghyun1038.tistory.com/24 https://developer.android.com/training/gestures/viewgroup?hl=ko https://developer.android.com/guide/topics/graphics/prop-animation?hl=ko</summary></entry><entry><title type="html">Android Intro Activity - font family / text animation</title><link href="http://localhost:4000/android-ui/android-intro-activity-2-font-family-text-animation/" rel="alternate" type="text/html" title="Android Intro Activity - font family / text animation" /><published>2020-10-20T00:00:00+09:00</published><updated>2020-10-20T00:00:00+09:00</updated><id>http://localhost:4000/android-ui/android-intro-activity-2-font-family-text-animation</id><content type="html" xml:base="http://localhost:4000/android-ui/android-intro-activity-2-font-family-text-animation/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://www.journaldev.com/9481/android-animation-example&quot;&gt;https://www.journaldev.com/9481/android-animation-example&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/training/animation/reveal-or-hide-view?hl=ko&quot;&gt;https://developer.android.com/training/animation/reveal-or-hide-view?hl=ko&lt;/a&gt;
&lt;a href=&quot;https://woovictory.github.io/2020/06/12/Android-Font/&quot;&gt;https://woovictory.github.io/2020/06/12/Android-Font/&lt;/a&gt;&lt;/p&gt;

&lt;p float=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/gif/2020-10-2021-28.gif&quot; width=&quot;300&quot; /&gt;
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TextView를 추가하고 애니메이션 fade in 애니메이션 적용&lt;/li&gt;
  &lt;li&gt;custom font 다운받아 적용&lt;/li&gt;
  &lt;li&gt;Coroutine 맛보기&lt;/li&gt;
  &lt;li&gt;Activity 전환 애니메이션 적용&lt;/li&gt;
  &lt;li&gt;Ststus bar 크기를 구하고 로고의 위치 조정&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;resanimfadeinxml--fadeoutxml&quot;&gt;res/anim/fadein.xml , fadeout.xml&lt;/h2&gt;
&lt;p&gt;fadein.xml&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:fillAfter=&quot;true&quot;&amp;gt;

    &amp;lt;alpha
        android:duration=&quot;1000&quot;
        android:fromAlpha=&quot;0.0&quot;
        android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
        android:toAlpha=&quot;1.0&quot; /&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;fadeout.xml&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:fillAfter=&quot;true&quot; &amp;gt;

    &amp;lt;alpha
        android:duration=&quot;1000&quot;
        android:fromAlpha=&quot;1.0&quot;
        android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
        android:toAlpha=&quot;0.0&quot; /&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;res 디렉토리에 anim 디렉토리를 추가하고 fadein.xml, fadeout.xml을 추가한다.&lt;/li&gt;
  &lt;li&gt;alpah는 물체의 불투명도(opacity)를 참조한다. 낮으면 투명해지고 높을수록 불투명하다.
    &lt;ul&gt;
      &lt;li&gt;애니메이션에서 fade란 알파값을 0에서 1로 변경하는것에 불과하다.&lt;/li&gt;
      &lt;li&gt;fadeout은 정 반대로 지정하면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;interpolator(보간)는 시작지점과 종료시점까지의 변화 과정을 어떤 식으로 표현할 것인가를 애니메이션으로 정의한 것이다.
    &lt;ul&gt;
      &lt;li&gt;accelerate_interpolator는 시작지점 속도가 0으로 시작하여 점점 증가한다.&lt;/li&gt;
      &lt;li&gt;accelerate_decelerate_interpolaotr (0부터 시작하여 증가했다가 마지막에 0으로 감소)  .. 등등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;introactivitykt-에-animation-구현&quot;&gt;IntroActivity.kt 에 animation 구현&lt;/h2&gt;
&lt;p&gt;onCreate() 내부&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
  var statusBarHeight:Int = 0;
  var resId = resources.getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;)
        
  if (resId &amp;gt; 0) {
    statusBarHeight = resources.getDimensionPixelSize(resId)
  }

  Log.e(&quot;barHeight&quot;, statusBarHeight.toString()) // result : 63 -&amp;gt; 디바이스에 따라 다를것으로 예상됨
				
  val introLogo = findViewById&amp;lt;TextView&amp;gt;(R.id.intro_logo)
  introLogo.setPadding(0,statusBarHeight,0,0)
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;IntroActivity는 statusBar(상태바)를 띄우지 않고 MainActivity에서는 띄우게 된다.
    &lt;ul&gt;
      &lt;li&gt;이로인해 정 중앙에 위치하는 TextView 로고가 activity 이동시 아래로 내려가는 것 처럼 보이게 된다.&lt;/li&gt;
      &lt;li&gt;위 코드는 앱 시작시 상태바의 높이를 구하고 TextView에 Padding Top 에 입력하여 다음 화면과 동일하게 로고의 위치를 고정하기 위함이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        val logoAnimation = AnimationUtils.loadAnimation(applicationContext,R.anim.fadein);
        introLogo.startAnimation(logoAnimation)
        
       CoroutineScope(Dispatchers.Main).launch {
           withContext(CoroutineScope(Dispatchers.Default).coroutineContext) {
               delay(4000L)
               val intent = Intent(this@IntroActivity, MainActivity::class.java)
               startActivity(intent)
               overridePendingTransition(R.anim.fadein, R.anim.fadeout)
               finish()
           }
       }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;AnimationUtils.loadAnimation() 메소드로 위에서 생성한 fadein.xml 을 호출한다.&lt;/li&gt;
  &lt;li&gt;startAnimation() 메소드에 입력하여 애니메이션을 시작한다.&lt;/li&gt;
  &lt;li&gt;delay를 위해 코루틴이 활용되었다.   4초뒤 MainActivity로 넘어가는 로직이다.&lt;/li&gt;
  &lt;li&gt;startActivity() 뒤에 overridePendingTransition() 메소드를 활용하면 액티비티 전환 애니메이션을 컨트롤할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;위 로직은 fadeout을 구현하였다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;resfontapp_fontxml&quot;&gt;res/font/app_font.xml&lt;/h2&gt;
&lt;p&gt;인터넷 상에서 무료로 사용할 수 있는 폰트를 다운받아 res/font 폴더에 저장하고 다음 xml을 생성한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;font-family xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    tools:ignore=&quot;UnusedAttribute,ResourceCycle&quot;&amp;gt;

    &amp;lt;font
        android:font=&quot;@font/gong_gothic_light&quot;
        android:fontStyle=&quot;normal&quot;
        android:fontWeight=&quot;300&quot;
        app:font=&quot;@font/gong_gothic_light&quot;
        app:fontStyle=&quot;normal&quot;
        app:fontWeight=&quot;300&quot; /&amp;gt;

    &amp;lt;!--bold--&amp;gt;
    &amp;lt;font
        android:font=&quot;@font/gong_gothic_bold&quot;
        android:fontStyle=&quot;normal&quot;
        android:fontWeight=&quot;500&quot;
        app:font=&quot;@font/gong_gothic_bold&quot;
        app:fontStyle=&quot;normal&quot;
        app:fontWeight=&quot;500&quot; /&amp;gt;

    &amp;lt;!--medium--&amp;gt;
    &amp;lt;font
        android:font=&quot;@font/gong_gothic_medium&quot;
        android:fontStyle=&quot;normal&quot;
        android:fontWeight=&quot;1000&quot;
        app:font=&quot;@font/gong_gothic_medium&quot;
        app:fontStyle=&quot;normal&quot;
        app:fontWeight=&quot;1000&quot; /&amp;gt;

&amp;lt;/font-family&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;모든 폰트에 적용하는 방법과 styles.xml에 등록하여 필요한 곳에서만 사용하는 방법이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;res/values/styles.xml에 다음과 같이 등록해서 사용한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;style name=&quot;Text.RankStyle&quot; parent=&quot;android:TextAppearance&quot;&amp;gt;
        &amp;lt;item name=&quot;android:textStyle&quot;&amp;gt;normal&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:textSize&quot;&amp;gt;14dp&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:textColor&quot;&amp;gt;@color/light_grey&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:fontFamily&quot;&amp;gt;@font/app_font&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:includeFontPadding&quot;&amp;gt;false&amp;lt;/item&amp;gt;
    &amp;lt;/style&amp;gt;

    &amp;lt;style name=&quot;Text.TitleStyle&quot; parent=&quot;android:TextAppearance&quot;&amp;gt;
        &amp;lt;item name=&quot;android:textStyle&quot;&amp;gt;bold&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:textSize&quot;&amp;gt;16dp&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:textColor&quot;&amp;gt;@color/black&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:fontFamily&quot;&amp;gt;@font/app_font&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:includeFontPadding&quot;&amp;gt;false&amp;lt;/item&amp;gt;
    &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TextView 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JroomUI&lt;/code&gt; 로고 텍스트에 폰트를 적용해보자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;TextView
        android:id=&quot;@+id/intro_logo&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;@string/app_name&quot;
        android:textSize=&quot;30sp&quot;
        style=&quot;@style/Text.TitleStyle&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;style=&quot;@style/Text.TitleStyle&quot;&lt;/code&gt; 처럼 적용하여 사용한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hun</name></author><category term="android-ui" /><category term="AndroidUI" /><category term="AnroidAnimation" /><category term="Kotlin" /><category term="Android" /><summary type="html">참고자료 https://www.journaldev.com/9481/android-animation-example https://developer.android.com/training/animation/reveal-or-hide-view?hl=ko https://woovictory.github.io/2020/06/12/Android-Font/</summary></entry><entry><title type="html">Android Intro Activity - animations using lottie</title><link href="http://localhost:4000/android-ui/android-intro-activity-animations-using-lottie/" rel="alternate" type="text/html" title="Android Intro Activity - animations using lottie" /><published>2020-10-20T00:00:00+09:00</published><updated>2020-10-20T00:00:00+09:00</updated><id>http://localhost:4000/android-ui/android-intro-activity-animations-using-lottie</id><content type="html" xml:base="http://localhost:4000/android-ui/android-intro-activity-animations-using-lottie/">&lt;p&gt;참고자료
&lt;a href=&quot;https://www.youtube.com/watch?v=n7XTizCon0A&quot;&gt;https://www.youtube.com/watch?v=n7XTizCon0A&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/kotlin/coroutines?hl=ko&quot;&gt;https://developer.android.com/kotlin/coroutines?hl=ko&lt;/a&gt;
&lt;a href=&quot;https://lottiefiles.com/&quot;&gt;https://lottiefiles.com/&lt;/a&gt;&lt;/p&gt;

&lt;p float=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/gif/2020-10-2017-03.gif&quot; width=&quot;300&quot; /&gt;
&lt;/p&gt;
&lt;h2 id=&quot;buildgradle&quot;&gt;build.gradle&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9'
implementation 'com.airbnb.android:lottie:3.4.0'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;resvaluesstylesxml&quot;&gt;res/values/styles.xml&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&amp;gt;
...
&amp;lt;/style&amp;gt;

&amp;lt;style name=&quot;FullScreen&quot; parent=&quot;AppTheme&quot;&amp;gt;
  &amp;lt;item name=&quot;android:windowNoTitle&quot;&amp;gt;true&amp;lt;/item&amp;gt;
  &amp;lt;item name=&quot;android:windowActionBar&quot;&amp;gt;false&amp;lt;/item&amp;gt;
  &amp;lt;item name=&quot;android:windowFullscreen&quot;&amp;gt;true&amp;lt;/item&amp;gt;
  &amp;lt;item name=&quot;android:windowContentOverlay&quot;&amp;gt;@null&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;AppTheme은 안드로이드 프로젝트 생성 시 디폴트로 생성되는 테마이다.
    &lt;ul&gt;
      &lt;li&gt;이것을 NoActionBar로 지정한다. (추후 ActionBar는 필요시 toolbar를 추가해서 구현)&lt;/li&gt;
      &lt;li&gt;로 새로운 stype의 테마를 지정할 수 있다.&lt;/li&gt;
      &lt;li&gt;기본 테마를 상속받는다.  (기본 컬러가 지정되어있으며 그것을 따르게 됨)&lt;/li&gt;
      &lt;li&gt;내부 item 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;adroidmanifestxml&quot;&gt;AdroidManifest.xml&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
&amp;lt;activity android:name=&quot;.IntroActivity&quot;
  android:theme=&quot;@style/FullScreen&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
      &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt;
      &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/activity&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;맨 처음으로 IntroActivity가 실행되도록 action.Main와 caegory.LAUNCHER를 변경&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lottiefilescom&quot;&gt;lottiefiles.com&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;애니메이션을 선택하고 lottie.json 으로 다운로드&lt;/li&gt;
  &lt;li&gt;res 위치에 raw 디렉토리 생성하고 다운로드받은 json 파일 이동시킨다.&lt;/li&gt;
  &lt;li&gt;bulid.gradle에 추가한 lottie 라이브러리를 활용하여 xml에서 다운로드받은 json 파일을 랜더링 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;activity_introxml&quot;&gt;activity_intro.xml&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;vertical&quot;
    tools:context=&quot;.IntroActivity&quot;&amp;gt;

    &amp;lt;com.airbnb.lottie.LottieAnimationView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:lottie_rawRes=&quot;@raw/intro&quot;
        app:lottie_autoPlay=&quot;true&quot;
        app:lottie_loop=&quot;true&quot;/&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;introactivitykt&quot;&gt;IntroActivity.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class IntroActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_intro)
        
        // Coroutine
       CoroutineScope(Dispatchers.Main).launch {
           withContext(CoroutineScope(Dispatchers.Default).coroutineContext) {
               delay(5000L)
               val intent = Intent(this@IntroActivity, MainActivity::class.java)
               startActivity(intent)
               finish()
           }
       }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;5초뒤 MainActivity로 이동하고 IntroActivity 는 finish()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;</content><author><name>Hun</name></author><category term="android-ui" /><category term="Kotlin" /><category term="AndroidUI" /><category term="AnroidAnimation" /><summary type="html">참고자료 https://www.youtube.com/watch?v=n7XTizCon0A https://developer.android.com/kotlin/coroutines?hl=ko https://lottiefiles.com/</summary></entry><entry><title type="html">Data structure - Kotlin Constructing Collections</title><link href="http://localhost:4000/data-structure-2-kotlin-constructing-collections/" rel="alternate" type="text/html" title="Data structure - Kotlin Constructing Collections" /><published>2020-10-20T00:00:00+09:00</published><updated>2020-10-20T00:00:00+09:00</updated><id>http://localhost:4000/data-structure-2-kotlin-constructing-collections</id><content type="html" xml:base="http://localhost:4000/data-structure-2-kotlin-constructing-collections/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://kotlinlang.org/docs/reference/constructing-collections.html&quot;&gt;https://kotlinlang.org/docs/reference/constructing-collections.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;코틀린 학습 + 영어 공부를 위해 kotlin 가이드 문서를 번역함&lt;/p&gt;

&lt;h2 id=&quot;kotlin-constructing-collections&quot;&gt;Kotlin Constructing Collections&lt;/h2&gt;</content><author><name>Hun</name></author><summary type="html">참고자료 https://kotlinlang.org/docs/reference/constructing-collections.html</summary></entry><entry><title type="html">Java와 Kotlin을 비교하면서 알아보는 객체지향 프로그래밍(OOP) - Class</title><link href="http://localhost:4000/javaandkotlin/java-kotlin-oop/" rel="alternate" type="text/html" title="Java와 Kotlin을 비교하면서 알아보는 객체지향 프로그래밍(OOP) - Class" /><published>2020-10-20T00:00:00+09:00</published><updated>2020-10-20T00:00:00+09:00</updated><id>http://localhost:4000/javaandkotlin/java-kotlin-oop</id><content type="html" xml:base="http://localhost:4000/javaandkotlin/java-kotlin-oop/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://opentutorials.org/course/743/6553&quot;&gt;https://opentutorials.org/course/743/6553&lt;/a&gt;
&lt;a href=&quot;https://wikidocs.net/214&quot;&gt;https://wikidocs.net/214&lt;/a&gt;
&lt;a href=&quot;https://kotlinlang.org/docs/reference/classes.html&quot;&gt;https://kotlinlang.org/docs/reference/classes.html&lt;/a&gt;
&lt;a href=&quot;https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html&quot;&gt;https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;class&quot;&gt;Class&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// java
class Car {}

// kotlin 
class Car {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;가장 간단한 형태의 클래스이다. 자바와 코틀린의 문법상의 차이는 없다. (현재까지는..) &lt;br /&gt;
클래스의 선언만 있고 내용은 없는 껍데기 클래스이다. 하지만 이러한 껍데기라도 중요한 기능을 가지고 있다.  객체를 생성하는 기능이다. &lt;br /&gt;
다음과 같이 만들 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//java
Car car = new Car();

//kotlin
val car = Car() 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;코틀린에선 new 키워드가 없다는 차이점이 있다.  또한 val 이란 키워드를 사용하고 이는 생성된 객체가 불변(immutable type)임을 명시하는 것인데 여기선 아직 중요하지 않으니 넘어가도록 하자.&lt;/p&gt;

&lt;p&gt;! 여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car()&lt;/code&gt;는 Class 이고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car&lt;/code&gt;는 객체이며 instance 이다. 객체(object)와 instance는 흡사하지만 차이점이 있다. 위에서 생성된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car&lt;/code&gt;라는 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car()&lt;/code&gt; 클래스의 instance이다. instance는 특정 객체가 어떤 클래스의 객체인지를 설명할 때 사용된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car&lt;/code&gt;는 객체이다.
    &lt;ul&gt;
      &lt;li&gt;구현할 대상이자 생성 된 실체 (추상적개념의 원본)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car()&lt;/code&gt;의 instance이다.
    &lt;ul&gt;
      &lt;li&gt;설계를 바탕으로 구현된 구체적인 실체
        &lt;ul&gt;
          &lt;li&gt;객체를 실체화 한 것&lt;/li&gt;
          &lt;li&gt;실체화 된 인스턴스는 메모리에 할당된다.&lt;/li&gt;
          &lt;li&gt;추상적 개념의 원본으로 부터 생성 된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복제본&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체-변수-instance-variable&quot;&gt;객체 변수 (Instance variable)&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car()&lt;/code&gt; 라는 껍데기 클래스에 의해 생성된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car&lt;/code&gt; 객체에 이름을 붙여주자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//java 
class Car {
  String name;
}

//kotlin
class Car {
  var name: String = &quot;Tucsan&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;클래스 내부에 선언된 변수를 객체변수(or 멤버변수) 라고 부른다.  코틀린에선 var 키워드로 객체가 가변 (mutable type)임을 명시한다.  String으로 선언이 되어있기 때문에 “Tucsan”과 같이 객체를 초기화 해야 에러가 발생하지 않는다. 반면 자바에선 초기화하지 않아도 된다.&lt;/p&gt;

&lt;p&gt;! NullPointException &lt;br /&gt;
위처럼 자바에선 객체의 기본값 초기화를 강제하지 않는다. 이는 NullPointException이 발생할 확률이 높아지며 이를 대처해야한다. try catch를 활용하여 대처하는데 이는 소스코드의 양이 많아지게 되며 유지보수시 어려움을 겪게 된다.  코틀린은 변수에 대하여 어떤 값을 가지고 어떤 값이 바뀔 여지가 있는지 고민하여 코드를 작성하게 도와주어 NullPointException을 막는다. 변수에 값을 초기화하지 않으면 에러가 발생하는 것처럼.&lt;/p&gt;

&lt;p&gt;!객체 변수에 접근하는 방법&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// java 
Car car = new Car();
system.out.println(car.name)

result : null

// kotlin
var car = Car()
println(car.name)

result : Tusan 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;메소드-method&quot;&gt;메소드 (method)&lt;/h2&gt;
&lt;p&gt;객체 변수에 값을 대입하여 보자. 다양한 방법이 있지만 일반적으로 메소드를 활용한다. 메소드는 클래스 내에 구현된 함수를 의미한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// java
class Car {
  String name;
  public void setName(String name) {
    this.name = name;
  }
}

//main 
Car car = new Car();
car.setName(&quot;Avante&quot;);
system.out.println(car.name); 

result : Avante

// kotlin
class Car {
  var name: String = &quot;&quot;
}

//main
var car = Car()
car.name = &quot;Tucsan&quot;
println(car.name)

result : Tusan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;자바에서 구현한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setName()&lt;/code&gt; 메소드는 객체지향에서 클래스내부에 기본적으로 구현하게 되는 getter/setter 메소드중 setter에 속하는 메소드이다. 멤버 변수에 직접적으로 접근하여 변경하는 것이 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car.setName(&quot;Avante&quot;)&lt;/code&gt; 처럼 setter 메소드를 통해 접근하여 값을 지정하는 것이다. 반면 코틀린에선 변수 선언시 컴파일러에서 자동으로 get/set 함수를 생성하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car.name = &quot;Tusan&quot;&lt;/code&gt; 처럼 값을 바로 입력할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;객체-변수는-공유되지-않는다&quot;&gt;객체 변수는 공유되지 않는다&lt;/h2&gt;
&lt;p&gt;다음의 예를 살펴보자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// java
Car avante = new Car();
avante.setName(&quot;Avante&quot;)
Car tucsan = new Car();
tucsan.setName(&quot;Tucsan&quot;)
System.out.pirntln(avante.name)
System.out.println(tucsan.name)

result :
Avante
Tucsan

// kotlin
var avante = Car()
avante.name = &quot;Avante&quot;
var tucsan = Car()
tucsan.name = &quot;Tucsan&quot;
println(avante.name)
println(tucsan.name)

result : 
Avante
Tucsan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Hun</name></author><category term="JavaAndKotlin" /><category term="OOP" /><summary type="html">참고자료 https://opentutorials.org/course/743/6553 https://wikidocs.net/214 https://kotlinlang.org/docs/reference/classes.html https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html</summary></entry><entry><title type="html">Use espresso to android UI test</title><link href="http://localhost:4000/android-test/use-espresso-to-android-ui-test/" rel="alternate" type="text/html" title="Use espresso to android UI test" /><published>2020-10-20T00:00:00+09:00</published><updated>2020-10-20T00:00:00+09:00</updated><id>http://localhost:4000/android-test/use-espresso-to-android-ui-test</id><content type="html" xml:base="http://localhost:4000/android-test/use-espresso-to-android-ui-test/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&quot;&gt;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&lt;/a&gt;
&lt;a href=&quot;https://two22.tistory.com/12&quot;&gt;https://two22.tistory.com/12&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이전에 만들었던 introActivity를 test해보자.&lt;/p&gt;
&lt;h2 id=&quot;buildgradlemoduleapp&quot;&gt;build.gradle(Module:app)&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // local unit test
    testImplementation 'androidx.test.ext:junit:1.1.2'

    // android unit test
    androidTestImplementation 'androidx.test.ext:junit:1.1.2'

    // android ui test
    androidTestImplementation 'androidx.test:runner:1.3.0'
    androidTestImplementation 'androidx.test:rules:1.3.0'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
    androidTestImplementation 'androidx.test.espresso:espresso-contrib:3.3.0'
    androidTestImplementation 'androidx.test.espresso:espresso-intents:3.3.0'
    androidTestImplementation 'androidx.test.espresso.idling:idling-concurrent:3.3.0'
    implementation 'androidx.test.espresso:espresso-idling-resource:3.3.0'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Junit =&amp;gt; Java의 대표적인 Testing Framework
    &lt;ul&gt;
      &lt;li&gt;java 이외에도 각각의 언어에 테스트 프레임워크가 있다. (CUnit, PyUnit …)&lt;/li&gt;
      &lt;li&gt;똑같은 junit이 testImplementation과 androidTestImplementation으로 추가되어 있는 이유
        &lt;ul&gt;
          &lt;li&gt;app/src에는 main / test / androidTest 패키지로 나뉘어져 있다.
            &lt;ul&gt;
              &lt;li&gt;main =&amp;gt; 실제 동작하는 코드&lt;/li&gt;
              &lt;li&gt;test =&amp;gt; unit test를 구현한 코드&lt;/li&gt;
              &lt;li&gt;androidTest =&amp;gt; ui test를 구현한 코드 (화면터치, 표시내용 등 )
                &lt;ul&gt;
                  &lt;li&gt;testImplementation =&amp;gt; test 소스 세트에 대한 종속성 추가&lt;/li&gt;
                  &lt;li&gt;androidTestImplementation =&amp;gt; androidTest 소스 세트에 대한 종속성 추가&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;runner
    &lt;ul&gt;
      &lt;li&gt;ui test 관련된 espresso 및 ui automator 프레임워크를 실행&lt;/li&gt;
      &lt;li&gt;Junit 테스트 클래스를 실행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rules
    &lt;ul&gt;
      &lt;li&gt;Junit 규칙 셋&lt;/li&gt;
      &lt;li&gt;테스트에 필요한 상용구 코드를 줄이고 유연성을 높임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;espresso-core   / epresso-contrib / espresso-intents  / idling-concurrent / idling-resource
    &lt;ul&gt;
      &lt;li&gt;안드로이드에서 ui test를 위해 대표적으로 사용하는 라이브러리&lt;/li&gt;
      &lt;li&gt;core =&amp;gt; espresso의 기본 메소드가 담긴 패키지&lt;/li&gt;
      &lt;li&gt;contrilb =&amp;gt; DatePicker, RecyclerView, Drawer 등을 지원 하는 패키지&lt;/li&gt;
      &lt;li&gt;intents =&amp;gt; 폐쇄적 테스트를 위한 인턴트 확장이 담긴 패키지&lt;/li&gt;
      &lt;li&gt;idling
        &lt;ul&gt;
          &lt;li&gt;어떠한 ui의 동작을 테스트할 때 특정 동작의 완료를 기다려야하는 상황에서 Espresso는 해당 작업의 종료를 기다리는 방법을 모름&lt;/li&gt;
          &lt;li&gt;idling을 작성하여 Espresso가 대기할 수 있도록 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;androidtestintroscreentestkt&quot;&gt;(androidTest)IntroScreenTest.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(AndroidJUnit4::class)
@LargeTest
class IntroScreenTest {
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@RunWith(AndroidJUnit4::class)
    &lt;ul&gt;
      &lt;li&gt;해당 클래스가 Test 클래스임을 명시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;@LargeTest
    &lt;ul&gt;
      &lt;li&gt;외부 파일 시스템, 네트워크 등에 액세스할 수 있음&lt;/li&gt;
      &lt;li&gt;@SmallTest =&amp;gt; 파일시스템이나 네트워크와 상호작용하지 않음&lt;/li&gt;
      &lt;li&gt;@Medium =&amp;gt; localhost만 액세스&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @get: Rule
    var activityScenarioRule: ActivityScenarioRule&amp;lt;IntroActivity&amp;gt; =
        ActivityScenarioRule(
            Intent(
                ApplicationProvider.getApplicationContext(),
                IntroActivity::class.java
            ).apply { putExtra(&quot;MyArgs&quot;, &quot;Nothing&quot;) })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@get:Rule
    &lt;ul&gt;
      &lt;li&gt;ActivityScenarioRule을 사용하기 위함&lt;/li&gt;
      &lt;li&gt;Testing  진행할 activity를 연결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Before
    fun setUp() {
        activityScenarioRule.scenario.onActivity { it -&amp;gt;
            (it.findViewById&amp;lt;ConstraintLayout&amp;gt;(R.id.intro_cl))?.let {
            
            }
            (it.findViewById&amp;lt;TextView&amp;gt;(R.id.intro_logo))?.let {
                // it.text = &quot;ChangeUI&quot;
            }
        }
    }
    
    @After
    fun close() {
        activityScenarioRule.scenario.close()
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@Before
    &lt;ul&gt;
      &lt;li&gt;테스트 이전에 실행 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;@After
    &lt;ul&gt;
      &lt;li&gt;테스트 이후에 실행 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ActivityScenarioRule.scenario
    &lt;ul&gt;
      &lt;li&gt;로컬 단위 테스트 및 기기 내 통합 테스트에서 모두 사용할 수 있는 크로스 플랫폼 API 이다.&lt;/li&gt;
      &lt;li&gt;테스트 계측 스레드와 테스트실행 스레드를 동기화한다.&lt;/li&gt;
      &lt;li&gt;onActivity { } 내부에 연결된 activity의 xml view 들을 찾아서 연결할 수 있다.&lt;/li&gt;
      &lt;li&gt;테스트에서 글자입력 혹은 클릭등이 필요한경우 셋팅할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Test
    fun resultTest() {
        activityScenarioRule.scenario.onActivity {
            it.setResult(Activity.RESULT_OK, Intent().apply { putExtra(&quot;Result&quot;, &quot;Ok&quot;) })
            it.finish()
        }
        Assert.assertEquals(activityScenarioRule.scenario.result.resultCode, Activity.RESULT_OK)
        val result = activityScenarioRule.scenario.result.resultData?.extras?.getString(&quot;Result&quot;)
        Assert.assertEquals(result, &quot;Ok&quot;)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@Test
    &lt;ul&gt;
      &lt;li&gt;해당 함수가 테스트용 함수임을 나타냄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ActivityScenarioRule.scenario.onActivity {}
    &lt;ul&gt;
      &lt;li&gt;테스트 시 체크할 사항들을 구현할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Assert
    &lt;ul&gt;
      &lt;li&gt;테스트의 수행결과를 판별하는데 사용한다.&lt;/li&gt;
      &lt;li&gt;assertEquals(a,b) =&amp;gt; 입력된 a,b 가 일치하는지 확인
        &lt;ul&gt;
          &lt;li&gt;이 외에도 assertFalse() , assertNotNull(), assertFail() 등의 메소드가 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Test
    fun moveToStateTest() {
        activityScenarioRule.scenario?.let {
            it.moveToState(Lifecycle.State.STARTED)
            Assert.assertEquals(it.state, Lifecycle.State.STARTED)
            it.moveToState(Lifecycle.State.CREATED)
            Assert.assertEquals(it.state, Lifecycle.State.CREATED)
            it.moveToState(Lifecycle.State.RESUMED)
            Assert.assertEquals(it.state, Lifecycle.State.RESUMED)
            it.moveToState(Lifecycle.State.DESTROYED)
            Assert.assertEquals(it.state, Lifecycle.State.DESTROYED)
            // activityScenario.recreate()
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;moveToStae()
    &lt;ul&gt;
      &lt;li&gt;액티비티의 라이프 사이클을 임의로 변경할 수 있음&lt;/li&gt;
      &lt;li&gt;현재상태를 Lifecycle.State 변수를 통해 확인가능&lt;/li&gt;
      &lt;li&gt;recreate 메소드를 이용하면 앱을 onSaveInstanceState와 함께 재실행할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lateinit var activityScenario: ActivityScenario&amp;lt;IntroActivity&amp;gt;
    
    @Before
    fun setUp() {
        activityScenario = ActivityScenario.launch(
            Intent(
                ApplicationProvider.getApplicationContext(),
                IntroActivity::class.java
            ).apply {
                putExtra(&quot;MyArgs&quot;, &quot;Nothing&quot;)
            })
        
        activityScenario.onActivity {
            (it.findViewById&amp;lt;ConstraintLayout&amp;gt;(R.id.intro_cl))?.let {
            
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;ActivityScenario만 단독으로 사용 가능&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hun</name></author><category term="android-test" /><category term="TDD" /><category term="AndroidUITest" /><summary type="html">참고자료 https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin https://two22.tistory.com/12</summary></entry></feed>