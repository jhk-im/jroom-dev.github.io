<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-10-22T16:20:23+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hun development blog</title><subtitle>Android &amp; Flutter &amp; Fullstack</subtitle><author><name>Hun</name></author><entry><title type="html">android swipe - 터치 좌표를 따라서 view 이동하기</title><link href="http://localhost:4000/android-ui/android-swipe-view/" rel="alternate" type="text/html" title="android swipe - 터치 좌표를 따라서 view 이동하기" /><published>2020-10-21T00:00:00+09:00</published><updated>2020-10-21T00:00:00+09:00</updated><id>http://localhost:4000/android-ui/android-swipe-view</id><content type="html" xml:base="http://localhost:4000/android-ui/android-swipe-view/">&lt;p&gt;참고자료
&lt;a href=&quot;https://sunghyun1038.tistory.com/24&quot;&gt;https://sunghyun1038.tistory.com/24&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/training/gestures/viewgroup?hl=ko&quot;&gt;https://developer.android.com/training/gestures/viewgroup?hl=ko&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/guide/topics/graphics/prop-animation?hl=ko&quot;&gt;https://developer.android.com/guide/topics/graphics/prop-animation?hl=ko&lt;/a&gt;&lt;/p&gt;

&lt;p float=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/gif/2020-10-2200-42.gif&quot; width=&quot;300&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;fragment_main_swipexml&quot;&gt;fragment_main_swipe.xml&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/intro_cl&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&amp;gt;

    &amp;lt;TextView
        style=&quot;@style/Text.RankStyle&quot;
        android:id=&quot;@+id/intro_login_text&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;@string/login&quot;
        android:textSize=&quot;20sp&quot;
        android:visibility=&quot;gone&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt;

    &amp;lt;com.airbnb.lottie.LottieAnimationView
        android:id=&quot;@+id/intro_swipe_up&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginStart=&quot;10dp&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot;
        app:layout_constraintBottom_toTopOf=&quot;@+id/intro_logo&quot;
        app:lottie_autoPlay=&quot;true&quot;
        app:lottie_loop=&quot;true&quot;
        app:lottie_rawRes=&quot;@raw/main_swipe_up&quot;/&amp;gt;

    &amp;lt;com.airbnb.lottie.LottieAnimationView
        android:id=&quot;@+id/intro_cursor&quot;
        android:layout_width=&quot;200dp&quot;
        android:layout_height=&quot;200dp&quot;
        android:layout_marginTop=&quot;30dp&quot;
        app:layout_constraintBottom_toBottomOf=&quot;@id/intro_logo&quot;
        app:layout_constraintLeft_toLeftOf=&quot;@id/intro_logo&quot;
        app:layout_constraintRight_toRightOf=&quot;@id/intro_logo&quot;
        app:layout_constraintTop_toTopOf=&quot;@id/intro_logo&quot;
        app:lottie_autoPlay=&quot;true&quot;
        app:lottie_loop=&quot;true&quot;
        app:lottie_rawRes=&quot;@raw/main_cursor&quot; /&amp;gt;

    &amp;lt;TextView
        android:id=&quot;@+id/intro_logo&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;@string/app_name&quot;
        android:textSize=&quot;30sp&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot;
        style=&quot;@style/Text.TitleStyle&quot;/&amp;gt;

    &amp;lt;com.airbnb.lottie.LottieAnimationView
        android:id=&quot;@+id/intro_swipe_down&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginEnd=&quot;10dp&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintTop_toBottomOf=&quot;@+id/intro_logo&quot;
        app:lottie_autoPlay=&quot;true&quot;
        app:lottie_loop=&quot;true&quot;
        app:lottie_rawRes=&quot;@raw/main_swipe_down&quot;/&amp;gt;

    &amp;lt;TextView
        style=&quot;@style/Text.RankStyle&quot;
        android:id=&quot;@+id/intro_guest_text&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;@string/guest&quot;
        android:textSize=&quot;20sp&quot;
        android:visibility=&quot;gone&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&amp;gt;
&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Constraintlayout =&amp;gt; parent layout
    &lt;ul&gt;
      &lt;li&gt;intro_login_text: TextView =&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOGIN&lt;/code&gt; text
        &lt;ul&gt;
          &lt;li&gt;visibility=gone  =&amp;gt; 처음엔 렌더링되지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;intro_swipe_up: LottieAnimation =&amp;gt; 중앙로고 클릭 시 위로 향하는 화살표 애니메이션&lt;/li&gt;
      &lt;li&gt;intro_cursr: LottieAnimation =&amp;gt; 로고 아래에 클릭을 유도하는 손모양 애니메이션&lt;/li&gt;
      &lt;li&gt;intro_logo : Textview =&amp;gt; 중앙로고&lt;/li&gt;
      &lt;li&gt;intro_swipe_down: LottieAnimation =&amp;gt; 중앙 로고 클릭 시 아래로 향하는 화살표 애니메이션&lt;/li&gt;
      &lt;li&gt;intro_guest_text: TextView =&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GUEST&lt;/code&gt; text&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mainswipefragmentkt&quot;&gt;MainSwipeFragment.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        
        return inflater.inflate(R.layout.fragment_main_swipe, container, false)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Fragment override 함수&lt;/li&gt;
  &lt;li&gt;inflater를 통해 위에서 생성한 xml 프래그먼트를 입력한다.&lt;/li&gt;
  &lt;li&gt;container는 activity에서 fragment 생성 시 입력받는다.
    &lt;ul&gt;
      &lt;li&gt;container =&amp;gt; 프래그먼트가 표시 될 액티비티&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private lateinit var parentView: ConstraintLayout
    private lateinit var logoSwipeButton: TextView
    private lateinit var loginTextView: TextView
    private lateinit var guestTextView: TextView
    
    private lateinit var cursorAnimation: LottieAnimationView
    private lateinit var swipeUpAnimation: LottieAnimationView
    private lateinit var swipeDownAnimation: LottieAnimationView
		
		...
		
		    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        logoSwipeButton = view.findViewById(R.id.intro_logo)
        cursorAnimation = view.findViewById(R.id.intro_cursor)
        
        swipeUpAnimation = view.findViewById(R.id.intro_swipe_up)
        swipeDownAnimation = view.findViewById(R.id.intro_swipe_down)
        swipeDownAnimation.visibility = View.GONE
        swipeUpAnimation.visibility = View.GONE
        
        parentView = view.findViewById(R.id.intro_cl)
        
        loginTextView = view.findViewById(R.id.intro_login_text)
        guestTextView = view.findViewById(R.id.intro_guest_text)
        
        var statusBarHeight: Int = 0
        var resId = resources.getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;)
        if (resId &amp;gt; 0) {
            statusBarHeight = resources.getDimensionPixelSize(resId)
        }
        
        setOnTouchListener(statusBarHeight)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;lateinit var로 위에서 생성한 각각의 뷰의 타입을 지정한다.
    &lt;ul&gt;
      &lt;li&gt;onView() 함수를 사용하여 view를 넘겨받아 findViewById로 xml내부의 뷰들과 연결한다.&lt;/li&gt;
      &lt;li&gt;swipedown, swipeup 애니메이션은 클릭 시 보여지기 때문에 visibility = gone 으로 설정한다.&lt;/li&gt;
      &lt;li&gt;상태바 크기를 구하는 이유는 중앙 로고를 스와이프로 이동하고 다시 원위치로 돌아갈 때 필요하기 때문이다.
        &lt;ul&gt;
          &lt;li&gt;중앙정렬에서 약간 빗나감&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;setOnTouchListener() 내부에 중앙로고인 logoSwipeButton에 리스너를 연결하여 구현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @SuppressLint(&quot;ClickableViewAccessibility&quot;, &quot;Recycle&quot;, &quot;ResourceAsColor&quot;)
    private fun setOnTouchListener(status: Int) {
        logoSwipeButton.setOnTouchListener { button, event -&amp;gt;
            //var parentWidth = parentView.width
            var parentHeight = parentView.height
            
						when (event!!.action) {
                MotionEvent.ACTION_DOWN -&amp;gt; {
                    cursorAnimation.visibility = View.GONE
                    guestTextView.visibility = View.VISIBLE
                    loginTextView.visibility = View.VISIBLE
                    swipeDownAnimation.visibility = View.VISIBLE
                    swipeUpAnimation.visibility = View.VISIBLE
                    swipeDownAnimation.playAnimation()
                    swipeUpAnimation.playAnimation()
                }
    
                MotionEvent.ACTION_UP -&amp;gt; {
                    button.y = ((parentHeight * 0.5f) - status)
                    button.visibility = View.VISIBLE
                    cursorAnimation.visibility = View.VISIBLE
                    swipeDownAnimation.visibility = View.GONE
                    swipeUpAnimation.visibility = View.GONE
                    guestTextView.visibility = View.GONE
                    loginTextView.visibility = View.GONE
                    guestTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f)
                    loginTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f)
                }
    
                MotionEvent.ACTION_MOVE -&amp;gt; {
                    button.y = button.y + (event.y - (button.height * 0.5f))
                    button.visibility = View.VISIBLE
                    guestTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f)
                    loginTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f)
                    when {
                        button.y &amp;lt; (parentHeight * 0.1f) - status -&amp;gt; {
                            button.visibility = View.GONE
                            loginTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 30f)
                        }
            
                        button.y &amp;gt; (parentHeight * 0.9f) - status -&amp;gt; {
                            button.visibility = View.GONE
                            guestTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 30f)
                        }
            
                        button.y &amp;lt; (parentHeight * 0.45f) - status ||
                                button.y &amp;gt; (parentHeight * 0.55f) - status  -&amp;gt; {
                            swipeUpAnimation.visibility = View.GONE
                            swipeDownAnimation.visibility = View.GONE
                        }
                    }
                }
            }
            true
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;MotionEvent.ACTION_DOWN
    &lt;ul&gt;
      &lt;li&gt;화면에 손가락이 닿는 순간을 의미함&lt;/li&gt;
      &lt;li&gt;눌려지는 순간 보여져야 할 상황이 구현되어 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MotionEvent.ACTION_UP
    &lt;ul&gt;
      &lt;li&gt;화면에서 손가락이 뗴어지는 순가을 의미함&lt;/li&gt;
      &lt;li&gt;변경된 사항들이 원래 위치로 reset 되도록 구현되어 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MotionEvent.ACTION_MOVE
    &lt;ul&gt;
      &lt;li&gt;터치 되어진 상태에서 움직임을 감지하는 모든 순간을 의미함&lt;/li&gt;
      &lt;li&gt;var parentHeight = parentView.height
        &lt;ul&gt;
          &lt;li&gt;현재 최상단 레이아웃의 실제 높이를 구현하고 좌표값을 구함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;button.y = button.y + (event.y - (button.height * 0.5f))
        &lt;ul&gt;
          &lt;li&gt;y축에서 터치된 손가락의 실제 좌표를 구함&lt;/li&gt;
          &lt;li&gt;y축만 구현되어있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;button.y &amp;lt; (parentHeight * 0.1f) - status
        &lt;ul&gt;
          &lt;li&gt;터치된 손가락이 최상단 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOGIN&lt;/code&gt; text 범위에 닿는 순간을 의미함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;button.y &amp;gt; (parentHeight * 0.9f) - status
        &lt;ul&gt;
          &lt;li&gt;터치된 손가락이 최하단 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GUEST&lt;/code&gt; text 범위에 닿는 순간을 의미함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;button.y &amp;lt; (parentHeight * 0.45f) - status&lt;/td&gt;
              &lt;td&gt; &lt;/td&gt;
              &lt;td&gt;button.y &amp;gt; (parentHeight * 0.55f) - status&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;중앙 로고를 기준으로 위 아래로 조금씩 움직였을 때의 범위를 의미함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mainactivitykt&quot;&gt;MainActivity.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        supportFragmentManager.beginTransaction()
            .replace(R.id.contentFrame, MainSwipeFragment())
            .commit()
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;supportFragmentManager =&amp;gt; 프래그먼트 생성&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hun</name></author><category term="android-ui" /><category term="AndroidUI" /><category term="AnroidAnimation" /><summary type="html">참고자료 https://sunghyun1038.tistory.com/24 https://developer.android.com/training/gestures/viewgroup?hl=ko https://developer.android.com/guide/topics/graphics/prop-animation?hl=ko</summary></entry><entry><title type="html">Android Intro Activity - font family / text animation</title><link href="http://localhost:4000/android-ui/android-intro-activity-2-font-family-text-animation/" rel="alternate" type="text/html" title="Android Intro Activity - font family / text animation" /><published>2020-10-20T00:00:00+09:00</published><updated>2020-10-20T00:00:00+09:00</updated><id>http://localhost:4000/android-ui/android-intro-activity-2-font-family-text-animation</id><content type="html" xml:base="http://localhost:4000/android-ui/android-intro-activity-2-font-family-text-animation/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://www.journaldev.com/9481/android-animation-example&quot;&gt;https://www.journaldev.com/9481/android-animation-example&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/training/animation/reveal-or-hide-view?hl=ko&quot;&gt;https://developer.android.com/training/animation/reveal-or-hide-view?hl=ko&lt;/a&gt;
&lt;a href=&quot;https://woovictory.github.io/2020/06/12/Android-Font/&quot;&gt;https://woovictory.github.io/2020/06/12/Android-Font/&lt;/a&gt;&lt;/p&gt;

&lt;p float=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/gif/2020-10-2021-28.gif&quot; width=&quot;300&quot; /&gt;
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TextView를 추가하고 애니메이션 fade in 애니메이션 적용&lt;/li&gt;
  &lt;li&gt;custom font 다운받아 적용&lt;/li&gt;
  &lt;li&gt;Coroutine 맛보기&lt;/li&gt;
  &lt;li&gt;Activity 전환 애니메이션 적용&lt;/li&gt;
  &lt;li&gt;Ststus bar 크기를 구하고 로고의 위치 조정&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;resanimfadeinxml--fadeoutxml&quot;&gt;res/anim/fadein.xml , fadeout.xml&lt;/h2&gt;
&lt;p&gt;fadein.xml&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:fillAfter=&quot;true&quot;&amp;gt;

    &amp;lt;alpha
        android:duration=&quot;1000&quot;
        android:fromAlpha=&quot;0.0&quot;
        android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
        android:toAlpha=&quot;1.0&quot; /&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;fadeout.xml&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:fillAfter=&quot;true&quot; &amp;gt;

    &amp;lt;alpha
        android:duration=&quot;1000&quot;
        android:fromAlpha=&quot;1.0&quot;
        android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;
        android:toAlpha=&quot;0.0&quot; /&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;res 디렉토리에 anim 디렉토리를 추가하고 fadein.xml, fadeout.xml을 추가한다.&lt;/li&gt;
  &lt;li&gt;alpah는 물체의 불투명도(opacity)를 참조한다. 낮으면 투명해지고 높을수록 불투명하다.
    &lt;ul&gt;
      &lt;li&gt;애니메이션에서 fade란 알파값을 0에서 1로 변경하는것에 불과하다.&lt;/li&gt;
      &lt;li&gt;fadeout은 정 반대로 지정하면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;interpolator(보간)는 시작지점과 종료시점까지의 변화 과정을 어떤 식으로 표현할 것인가를 애니메이션으로 정의한 것이다.
    &lt;ul&gt;
      &lt;li&gt;accelerate_interpolator는 시작지점 속도가 0으로 시작하여 점점 증가한다.&lt;/li&gt;
      &lt;li&gt;accelerate_decelerate_interpolaotr (0부터 시작하여 증가했다가 마지막에 0으로 감소)  .. 등등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;introactivitykt-에-animation-구현&quot;&gt;IntroActivity.kt 에 animation 구현&lt;/h2&gt;
&lt;p&gt;onCreate() 내부&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
  var statusBarHeight:Int = 0;
  var resId = resources.getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;)
        
  if (resId &amp;gt; 0) {
    statusBarHeight = resources.getDimensionPixelSize(resId)
  }

  Log.e(&quot;barHeight&quot;, statusBarHeight.toString()) // result : 63 -&amp;gt; 디바이스에 따라 다를것으로 예상됨
				
  val introLogo = findViewById&amp;lt;TextView&amp;gt;(R.id.intro_logo)
  introLogo.setPadding(0,statusBarHeight,0,0)
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;IntroActivity는 statusBar(상태바)를 띄우지 않고 MainActivity에서는 띄우게 된다.
    &lt;ul&gt;
      &lt;li&gt;이로인해 정 중앙에 위치하는 TextView 로고가 activity 이동시 아래로 내려가는 것 처럼 보이게 된다.&lt;/li&gt;
      &lt;li&gt;위 코드는 앱 시작시 상태바의 높이를 구하고 TextView에 Padding Top 에 입력하여 다음 화면과 동일하게 로고의 위치를 고정하기 위함이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        val logoAnimation = AnimationUtils.loadAnimation(applicationContext,R.anim.fadein);
        introLogo.startAnimation(logoAnimation)
        
       CoroutineScope(Dispatchers.Main).launch {
           withContext(CoroutineScope(Dispatchers.Default).coroutineContext) {
               delay(4000L)
               val intent = Intent(this@IntroActivity, MainActivity::class.java)
               startActivity(intent)
               overridePendingTransition(R.anim.fadein, R.anim.fadeout)
               finish()
           }
       }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;AnimationUtils.loadAnimation() 메소드로 위에서 생성한 fadein.xml 을 호출한다.&lt;/li&gt;
  &lt;li&gt;startAnimation() 메소드에 입력하여 애니메이션을 시작한다.&lt;/li&gt;
  &lt;li&gt;delay를 위해 코루틴이 활용되었다.   4초뒤 MainActivity로 넘어가는 로직이다.&lt;/li&gt;
  &lt;li&gt;startActivity() 뒤에 overridePendingTransition() 메소드를 활용하면 액티비티 전환 애니메이션을 컨트롤할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;위 로직은 fadeout을 구현하였다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;resfontapp_fontxml&quot;&gt;res/font/app_font.xml&lt;/h2&gt;
&lt;p&gt;인터넷 상에서 무료로 사용할 수 있는 폰트를 다운받아 res/font 폴더에 저장하고 다음 xml을 생성한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;font-family xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    tools:ignore=&quot;UnusedAttribute,ResourceCycle&quot;&amp;gt;

    &amp;lt;font
        android:font=&quot;@font/gong_gothic_light&quot;
        android:fontStyle=&quot;normal&quot;
        android:fontWeight=&quot;300&quot;
        app:font=&quot;@font/gong_gothic_light&quot;
        app:fontStyle=&quot;normal&quot;
        app:fontWeight=&quot;300&quot; /&amp;gt;

    &amp;lt;!--bold--&amp;gt;
    &amp;lt;font
        android:font=&quot;@font/gong_gothic_bold&quot;
        android:fontStyle=&quot;normal&quot;
        android:fontWeight=&quot;500&quot;
        app:font=&quot;@font/gong_gothic_bold&quot;
        app:fontStyle=&quot;normal&quot;
        app:fontWeight=&quot;500&quot; /&amp;gt;

    &amp;lt;!--medium--&amp;gt;
    &amp;lt;font
        android:font=&quot;@font/gong_gothic_medium&quot;
        android:fontStyle=&quot;normal&quot;
        android:fontWeight=&quot;1000&quot;
        app:font=&quot;@font/gong_gothic_medium&quot;
        app:fontStyle=&quot;normal&quot;
        app:fontWeight=&quot;1000&quot; /&amp;gt;

&amp;lt;/font-family&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;모든 폰트에 적용하는 방법과 styles.xml에 등록하여 필요한 곳에서만 사용하는 방법이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;res/values/styles.xml에 다음과 같이 등록해서 사용한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;style name=&quot;Text.RankStyle&quot; parent=&quot;android:TextAppearance&quot;&amp;gt;
        &amp;lt;item name=&quot;android:textStyle&quot;&amp;gt;normal&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:textSize&quot;&amp;gt;14dp&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:textColor&quot;&amp;gt;@color/light_grey&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:fontFamily&quot;&amp;gt;@font/app_font&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:includeFontPadding&quot;&amp;gt;false&amp;lt;/item&amp;gt;
    &amp;lt;/style&amp;gt;

    &amp;lt;style name=&quot;Text.TitleStyle&quot; parent=&quot;android:TextAppearance&quot;&amp;gt;
        &amp;lt;item name=&quot;android:textStyle&quot;&amp;gt;bold&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:textSize&quot;&amp;gt;16dp&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:textColor&quot;&amp;gt;@color/black&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:fontFamily&quot;&amp;gt;@font/app_font&amp;lt;/item&amp;gt;
        &amp;lt;item name=&quot;android:includeFontPadding&quot;&amp;gt;false&amp;lt;/item&amp;gt;
    &amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TextView 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JroomUI&lt;/code&gt; 로고 텍스트에 폰트를 적용해보자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;TextView
        android:id=&quot;@+id/intro_logo&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;@string/app_name&quot;
        android:textSize=&quot;30sp&quot;
        style=&quot;@style/Text.TitleStyle&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot;
        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;
        app:layout_constraintRight_toRightOf=&quot;parent&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;style=&quot;@style/Text.TitleStyle&quot;&lt;/code&gt; 처럼 적용하여 사용한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hun</name></author><category term="android-ui" /><category term="AndroidUI" /><category term="AnroidAnimation" /><category term="Kotlin" /><category term="Android" /><summary type="html">참고자료 https://www.journaldev.com/9481/android-animation-example https://developer.android.com/training/animation/reveal-or-hide-view?hl=ko https://woovictory.github.io/2020/06/12/Android-Font/</summary></entry><entry><title type="html">Android Intro Activity - animations using lottie</title><link href="http://localhost:4000/android-ui/android-intro-activity-animations-using-lottie/" rel="alternate" type="text/html" title="Android Intro Activity - animations using lottie" /><published>2020-10-20T00:00:00+09:00</published><updated>2020-10-20T00:00:00+09:00</updated><id>http://localhost:4000/android-ui/android-intro-activity-animations-using-lottie</id><content type="html" xml:base="http://localhost:4000/android-ui/android-intro-activity-animations-using-lottie/">&lt;p&gt;참고자료
&lt;a href=&quot;https://www.youtube.com/watch?v=n7XTizCon0A&quot;&gt;https://www.youtube.com/watch?v=n7XTizCon0A&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/kotlin/coroutines?hl=ko&quot;&gt;https://developer.android.com/kotlin/coroutines?hl=ko&lt;/a&gt;
&lt;a href=&quot;https://lottiefiles.com/&quot;&gt;https://lottiefiles.com/&lt;/a&gt;&lt;/p&gt;

&lt;p float=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/gif/2020-10-2017-03.gif&quot; width=&quot;300&quot; /&gt;
&lt;/p&gt;
&lt;h2 id=&quot;buildgradle&quot;&gt;build.gradle&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9'
implementation 'com.airbnb.android:lottie:3.4.0'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;resvaluesstylesxml&quot;&gt;res/values/styles.xml&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&amp;gt;
...
&amp;lt;/style&amp;gt;

&amp;lt;style name=&quot;FullScreen&quot; parent=&quot;AppTheme&quot;&amp;gt;
  &amp;lt;item name=&quot;android:windowNoTitle&quot;&amp;gt;true&amp;lt;/item&amp;gt;
  &amp;lt;item name=&quot;android:windowActionBar&quot;&amp;gt;false&amp;lt;/item&amp;gt;
  &amp;lt;item name=&quot;android:windowFullscreen&quot;&amp;gt;true&amp;lt;/item&amp;gt;
  &amp;lt;item name=&quot;android:windowContentOverlay&quot;&amp;gt;@null&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;AppTheme은 안드로이드 프로젝트 생성 시 디폴트로 생성되는 테마이다.
    &lt;ul&gt;
      &lt;li&gt;이것을 NoActionBar로 지정한다. (추후 ActionBar는 필요시 toolbar를 추가해서 구현)&lt;/li&gt;
      &lt;li&gt;로 새로운 stype의 테마를 지정할 수 있다.&lt;/li&gt;
      &lt;li&gt;기본 테마를 상속받는다.  (기본 컬러가 지정되어있으며 그것을 따르게 됨)&lt;/li&gt;
      &lt;li&gt;내부 item 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;adroidmanifestxml&quot;&gt;AdroidManifest.xml&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
&amp;lt;activity android:name=&quot;.IntroActivity&quot;
  android:theme=&quot;@style/FullScreen&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
      &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt;
      &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/activity&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;맨 처음으로 IntroActivity가 실행되도록 action.Main와 caegory.LAUNCHER를 변경&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lottiefilescom&quot;&gt;lottiefiles.com&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;애니메이션을 선택하고 lottie.json 으로 다운로드&lt;/li&gt;
  &lt;li&gt;res 위치에 raw 디렉토리 생성하고 다운로드받은 json 파일 이동시킨다.&lt;/li&gt;
  &lt;li&gt;bulid.gradle에 추가한 lottie 라이브러리를 활용하여 xml에서 다운로드받은 json 파일을 랜더링 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;activity_introxml&quot;&gt;activity_intro.xml&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;vertical&quot;
    tools:context=&quot;.IntroActivity&quot;&amp;gt;

    &amp;lt;com.airbnb.lottie.LottieAnimationView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:lottie_rawRes=&quot;@raw/intro&quot;
        app:lottie_autoPlay=&quot;true&quot;
        app:lottie_loop=&quot;true&quot;/&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;introactivitykt&quot;&gt;IntroActivity.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class IntroActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_intro)
        
        // Coroutine
       CoroutineScope(Dispatchers.Main).launch {
           withContext(CoroutineScope(Dispatchers.Default).coroutineContext) {
               delay(5000L)
               val intent = Intent(this@IntroActivity, MainActivity::class.java)
               startActivity(intent)
               finish()
           }
       }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;5초뒤 MainActivity로 이동하고 IntroActivity 는 finish()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;</content><author><name>Hun</name></author><category term="android-ui" /><category term="Kotlin" /><category term="AndroidUI" /><category term="AnroidAnimation" /><summary type="html">참고자료 https://www.youtube.com/watch?v=n7XTizCon0A https://developer.android.com/kotlin/coroutines?hl=ko https://lottiefiles.com/</summary></entry><entry><title type="html">Data structure - Kotlin Constructing Collections</title><link href="http://localhost:4000/data-structure-2-kotlin-constructing-collections/" rel="alternate" type="text/html" title="Data structure - Kotlin Constructing Collections" /><published>2020-10-20T00:00:00+09:00</published><updated>2020-10-20T00:00:00+09:00</updated><id>http://localhost:4000/data-structure-2-kotlin-constructing-collections</id><content type="html" xml:base="http://localhost:4000/data-structure-2-kotlin-constructing-collections/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://kotlinlang.org/docs/reference/constructing-collections.html&quot;&gt;https://kotlinlang.org/docs/reference/constructing-collections.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;코틀린 학습 + 영어 공부를 위해 kotlin 가이드 문서를 번역함&lt;/p&gt;

&lt;h2 id=&quot;kotlin-constructing-collections&quot;&gt;Kotlin Constructing Collections&lt;/h2&gt;</content><author><name>Hun</name></author><summary type="html">참고자료 https://kotlinlang.org/docs/reference/constructing-collections.html</summary></entry><entry><title type="html">Java와 Kotlin을 비교하면서 알아보는 객체지향 프로그래밍(OOP) - Class</title><link href="http://localhost:4000/javaandkotlin/java-kotlin-oop/" rel="alternate" type="text/html" title="Java와 Kotlin을 비교하면서 알아보는 객체지향 프로그래밍(OOP) - Class" /><published>2020-10-20T00:00:00+09:00</published><updated>2020-10-20T00:00:00+09:00</updated><id>http://localhost:4000/javaandkotlin/java-kotlin-oop</id><content type="html" xml:base="http://localhost:4000/javaandkotlin/java-kotlin-oop/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://opentutorials.org/course/743/6553&quot;&gt;https://opentutorials.org/course/743/6553&lt;/a&gt;
&lt;a href=&quot;https://wikidocs.net/214&quot;&gt;https://wikidocs.net/214&lt;/a&gt;
&lt;a href=&quot;https://kotlinlang.org/docs/reference/classes.html&quot;&gt;https://kotlinlang.org/docs/reference/classes.html&lt;/a&gt;
&lt;a href=&quot;https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html&quot;&gt;https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;class&quot;&gt;Class&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// java
class Car {}

// kotlin 
class Car {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;가장 간단한 형태의 클래스이다. 자바와 코틀린의 문법상의 차이는 없다. (현재까지는..) &lt;br /&gt;
클래스의 선언만 있고 내용은 없는 껍데기 클래스이다. 하지만 이러한 껍데기라도 중요한 기능을 가지고 있다.  객체를 생성하는 기능이다. &lt;br /&gt;
다음과 같이 만들 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//java
Car car = new Car();

//kotlin
val car = Car() 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;코틀린에선 new 키워드가 없다는 차이점이 있다.  또한 val 이란 키워드를 사용하고 이는 생성된 객체가 불변(immutable type)임을 명시하는 것인데 여기선 아직 중요하지 않으니 넘어가도록 하자.&lt;/p&gt;

&lt;p&gt;! 여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car()&lt;/code&gt;는 Class 이고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car&lt;/code&gt;는 객체이며 instance 이다. 객체(object)와 instance는 흡사하지만 차이점이 있다. 위에서 생성된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car&lt;/code&gt;라는 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car()&lt;/code&gt; 클래스의 instance이다. instance는 특정 객체가 어떤 클래스의 객체인지를 설명할 때 사용된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car&lt;/code&gt;는 객체이다.
    &lt;ul&gt;
      &lt;li&gt;구현할 대상이자 생성 된 실체 (추상적개념의 원본)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car()&lt;/code&gt;의 instance이다.
    &lt;ul&gt;
      &lt;li&gt;설계를 바탕으로 구현된 구체적인 실체
        &lt;ul&gt;
          &lt;li&gt;객체를 실체화 한 것&lt;/li&gt;
          &lt;li&gt;실체화 된 인스턴스는 메모리에 할당된다.&lt;/li&gt;
          &lt;li&gt;추상적 개념의 원본으로 부터 생성 된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복제본&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체-변수-instance-variable&quot;&gt;객체 변수 (Instance variable)&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Car()&lt;/code&gt; 라는 껍데기 클래스에 의해 생성된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car&lt;/code&gt; 객체에 이름을 붙여주자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//java 
class Car {
  String name;
}

//kotlin
class Car {
  var name: String = &quot;Tucsan&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;클래스 내부에 선언된 변수를 객체변수(or 멤버변수) 라고 부른다.  코틀린에선 var 키워드로 객체가 가변 (mutable type)임을 명시한다.  String으로 선언이 되어있기 때문에 “Tucsan”과 같이 객체를 초기화 해야 에러가 발생하지 않는다. 반면 자바에선 초기화하지 않아도 된다.&lt;/p&gt;

&lt;p&gt;! NullPointException &lt;br /&gt;
위처럼 자바에선 객체의 기본값 초기화를 강제하지 않는다. 이는 NullPointException이 발생할 확률이 높아지며 이를 대처해야한다. try catch를 활용하여 대처하는데 이는 소스코드의 양이 많아지게 되며 유지보수시 어려움을 겪게 된다.  코틀린은 변수에 대하여 어떤 값을 가지고 어떤 값이 바뀔 여지가 있는지 고민하여 코드를 작성하게 도와주어 NullPointException을 막는다. 변수에 값을 초기화하지 않으면 에러가 발생하는 것처럼.&lt;/p&gt;

&lt;p&gt;!객체 변수에 접근하는 방법&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// java 
Car car = new Car();
system.out.println(car.name)

result : null

// kotlin
var car = Car()
println(car.name)

result : Tusan 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;메소드-method&quot;&gt;메소드 (method)&lt;/h2&gt;
&lt;p&gt;객체 변수에 값을 대입하여 보자. 다양한 방법이 있지만 일반적으로 메소드를 활용한다. 메소드는 클래스 내에 구현된 함수를 의미한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// java
class Car {
  String name;
  public void setName(String name) {
    this.name = name;
  }
}

//main 
Car car = new Car();
car.setName(&quot;Avante&quot;);
system.out.println(car.name); 

result : Avante

// kotlin
class Car {
  var name: String = &quot;&quot;
}

//main
var car = Car()
car.name = &quot;Tucsan&quot;
println(car.name)

result : Tusan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;자바에서 구현한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setName()&lt;/code&gt; 메소드는 객체지향에서 클래스내부에 기본적으로 구현하게 되는 getter/setter 메소드중 setter에 속하는 메소드이다. 멤버 변수에 직접적으로 접근하여 변경하는 것이 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car.setName(&quot;Avante&quot;)&lt;/code&gt; 처럼 setter 메소드를 통해 접근하여 값을 지정하는 것이다. 반면 코틀린에선 변수 선언시 컴파일러에서 자동으로 get/set 함수를 생성하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;car.name = &quot;Tusan&quot;&lt;/code&gt; 처럼 값을 바로 입력할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;객체-변수는-공유되지-않는다&quot;&gt;객체 변수는 공유되지 않는다&lt;/h2&gt;
&lt;p&gt;다음의 예를 살펴보자.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// java
Car avante = new Car();
avante.setName(&quot;Avante&quot;)
Car tucsan = new Car();
tucsan.setName(&quot;Tucsan&quot;)
System.out.pirntln(avante.name)
System.out.println(tucsan.name)

result :
Avante
Tucsan

// kotlin
var avante = Car()
avante.name = &quot;Avante&quot;
var tucsan = Car()
tucsan.name = &quot;Tucsan&quot;
println(avante.name)
println(tucsan.name)

result : 
Avante
Tucsan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Hun</name></author><category term="JavaAndKotlin" /><category term="OOP" /><summary type="html">참고자료 https://opentutorials.org/course/743/6553 https://wikidocs.net/214 https://kotlinlang.org/docs/reference/classes.html https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html</summary></entry><entry><title type="html">Use espresso to android UI test</title><link href="http://localhost:4000/android-test/use-espresso-to-android-ui-test/" rel="alternate" type="text/html" title="Use espresso to android UI test" /><published>2020-10-20T00:00:00+09:00</published><updated>2020-10-20T00:00:00+09:00</updated><id>http://localhost:4000/android-test/use-espresso-to-android-ui-test</id><content type="html" xml:base="http://localhost:4000/android-test/use-espresso-to-android-ui-test/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&quot;&gt;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&lt;/a&gt;
&lt;a href=&quot;https://two22.tistory.com/12&quot;&gt;https://two22.tistory.com/12&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이전에 만들었던 introActivity를 test해보자.&lt;/p&gt;
&lt;h2 id=&quot;buildgradlemoduleapp&quot;&gt;build.gradle(Module:app)&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // local unit test
    testImplementation 'androidx.test.ext:junit:1.1.2'

    // android unit test
    androidTestImplementation 'androidx.test.ext:junit:1.1.2'

    // android ui test
    androidTestImplementation 'androidx.test:runner:1.3.0'
    androidTestImplementation 'androidx.test:rules:1.3.0'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
    androidTestImplementation 'androidx.test.espresso:espresso-contrib:3.3.0'
    androidTestImplementation 'androidx.test.espresso:espresso-intents:3.3.0'
    androidTestImplementation 'androidx.test.espresso.idling:idling-concurrent:3.3.0'
    implementation 'androidx.test.espresso:espresso-idling-resource:3.3.0'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Junit =&amp;gt; Java의 대표적인 Testing Framework
    &lt;ul&gt;
      &lt;li&gt;java 이외에도 각각의 언어에 테스트 프레임워크가 있다. (CUnit, PyUnit …)&lt;/li&gt;
      &lt;li&gt;똑같은 junit이 testImplementation과 androidTestImplementation으로 추가되어 있는 이유
        &lt;ul&gt;
          &lt;li&gt;app/src에는 main / test / androidTest 패키지로 나뉘어져 있다.
            &lt;ul&gt;
              &lt;li&gt;main =&amp;gt; 실제 동작하는 코드&lt;/li&gt;
              &lt;li&gt;test =&amp;gt; unit test를 구현한 코드&lt;/li&gt;
              &lt;li&gt;androidTest =&amp;gt; ui test를 구현한 코드 (화면터치, 표시내용 등 )
                &lt;ul&gt;
                  &lt;li&gt;testImplementation =&amp;gt; test 소스 세트에 대한 종속성 추가&lt;/li&gt;
                  &lt;li&gt;androidTestImplementation =&amp;gt; androidTest 소스 세트에 대한 종속성 추가&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;runner
    &lt;ul&gt;
      &lt;li&gt;ui test 관련된 espresso 및 ui automator 프레임워크를 실행&lt;/li&gt;
      &lt;li&gt;Junit 테스트 클래스를 실행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rules
    &lt;ul&gt;
      &lt;li&gt;Junit 규칙 셋&lt;/li&gt;
      &lt;li&gt;테스트에 필요한 상용구 코드를 줄이고 유연성을 높임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;espresso-core   / epresso-contrib / espresso-intents  / idling-concurrent / idling-resource
    &lt;ul&gt;
      &lt;li&gt;안드로이드에서 ui test를 위해 대표적으로 사용하는 라이브러리&lt;/li&gt;
      &lt;li&gt;core =&amp;gt; espresso의 기본 메소드가 담긴 패키지&lt;/li&gt;
      &lt;li&gt;contrilb =&amp;gt; DatePicker, RecyclerView, Drawer 등을 지원 하는 패키지&lt;/li&gt;
      &lt;li&gt;intents =&amp;gt; 폐쇄적 테스트를 위한 인턴트 확장이 담긴 패키지&lt;/li&gt;
      &lt;li&gt;idling
        &lt;ul&gt;
          &lt;li&gt;어떠한 ui의 동작을 테스트할 때 특정 동작의 완료를 기다려야하는 상황에서 Espresso는 해당 작업의 종료를 기다리는 방법을 모름&lt;/li&gt;
          &lt;li&gt;idling을 작성하여 Espresso가 대기할 수 있도록 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;androidtestintroscreentestkt&quot;&gt;(androidTest)IntroScreenTest.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(AndroidJUnit4::class)
@LargeTest
class IntroScreenTest {
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@RunWith(AndroidJUnit4::class)
    &lt;ul&gt;
      &lt;li&gt;해당 클래스가 Test 클래스임을 명시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;@LargeTest
    &lt;ul&gt;
      &lt;li&gt;외부 파일 시스템, 네트워크 등에 액세스할 수 있음&lt;/li&gt;
      &lt;li&gt;@SmallTest =&amp;gt; 파일시스템이나 네트워크와 상호작용하지 않음&lt;/li&gt;
      &lt;li&gt;@Medium =&amp;gt; localhost만 액세스&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @get: Rule
    var activityScenarioRule: ActivityScenarioRule&amp;lt;IntroActivity&amp;gt; =
        ActivityScenarioRule(
            Intent(
                ApplicationProvider.getApplicationContext(),
                IntroActivity::class.java
            ).apply { putExtra(&quot;MyArgs&quot;, &quot;Nothing&quot;) })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@get:Rule
    &lt;ul&gt;
      &lt;li&gt;ActivityScenarioRule을 사용하기 위함&lt;/li&gt;
      &lt;li&gt;Testing  진행할 activity를 연결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Before
    fun setUp() {
        activityScenarioRule.scenario.onActivity { it -&amp;gt;
            (it.findViewById&amp;lt;ConstraintLayout&amp;gt;(R.id.intro_cl))?.let {
            
            }
            (it.findViewById&amp;lt;TextView&amp;gt;(R.id.intro_logo))?.let {
                // it.text = &quot;ChangeUI&quot;
            }
        }
    }
    
    @After
    fun close() {
        activityScenarioRule.scenario.close()
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@Before
    &lt;ul&gt;
      &lt;li&gt;테스트 이전에 실행 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;@After
    &lt;ul&gt;
      &lt;li&gt;테스트 이후에 실행 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ActivityScenarioRule.scenario
    &lt;ul&gt;
      &lt;li&gt;로컬 단위 테스트 및 기기 내 통합 테스트에서 모두 사용할 수 있는 크로스 플랫폼 API 이다.&lt;/li&gt;
      &lt;li&gt;테스트 계측 스레드와 테스트실행 스레드를 동기화한다.&lt;/li&gt;
      &lt;li&gt;onActivity { } 내부에 연결된 activity의 xml view 들을 찾아서 연결할 수 있다.&lt;/li&gt;
      &lt;li&gt;테스트에서 글자입력 혹은 클릭등이 필요한경우 셋팅할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Test
    fun resultTest() {
        activityScenarioRule.scenario.onActivity {
            it.setResult(Activity.RESULT_OK, Intent().apply { putExtra(&quot;Result&quot;, &quot;Ok&quot;) })
            it.finish()
        }
        Assert.assertEquals(activityScenarioRule.scenario.result.resultCode, Activity.RESULT_OK)
        val result = activityScenarioRule.scenario.result.resultData?.extras?.getString(&quot;Result&quot;)
        Assert.assertEquals(result, &quot;Ok&quot;)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@Test
    &lt;ul&gt;
      &lt;li&gt;해당 함수가 테스트용 함수임을 나타냄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ActivityScenarioRule.scenario.onActivity {}
    &lt;ul&gt;
      &lt;li&gt;테스트 시 체크할 사항들을 구현할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Assert
    &lt;ul&gt;
      &lt;li&gt;테스트의 수행결과를 판별하는데 사용한다.&lt;/li&gt;
      &lt;li&gt;assertEquals(a,b) =&amp;gt; 입력된 a,b 가 일치하는지 확인
        &lt;ul&gt;
          &lt;li&gt;이 외에도 assertFalse() , assertNotNull(), assertFail() 등의 메소드가 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Test
    fun moveToStateTest() {
        activityScenarioRule.scenario?.let {
            it.moveToState(Lifecycle.State.STARTED)
            Assert.assertEquals(it.state, Lifecycle.State.STARTED)
            it.moveToState(Lifecycle.State.CREATED)
            Assert.assertEquals(it.state, Lifecycle.State.CREATED)
            it.moveToState(Lifecycle.State.RESUMED)
            Assert.assertEquals(it.state, Lifecycle.State.RESUMED)
            it.moveToState(Lifecycle.State.DESTROYED)
            Assert.assertEquals(it.state, Lifecycle.State.DESTROYED)
            // activityScenario.recreate()
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;moveToStae()
    &lt;ul&gt;
      &lt;li&gt;액티비티의 라이프 사이클을 임의로 변경할 수 있음&lt;/li&gt;
      &lt;li&gt;현재상태를 Lifecycle.State 변수를 통해 확인가능&lt;/li&gt;
      &lt;li&gt;recreate 메소드를 이용하면 앱을 onSaveInstanceState와 함께 재실행할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lateinit var activityScenario: ActivityScenario&amp;lt;IntroActivity&amp;gt;
    
    @Before
    fun setUp() {
        activityScenario = ActivityScenario.launch(
            Intent(
                ApplicationProvider.getApplicationContext(),
                IntroActivity::class.java
            ).apply {
                putExtra(&quot;MyArgs&quot;, &quot;Nothing&quot;)
            })
        
        activityScenario.onActivity {
            (it.findViewById&amp;lt;ConstraintLayout&amp;gt;(R.id.intro_cl))?.let {
            
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;ActivityScenario만 단독으로 사용 가능&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hun</name></author><category term="android-test" /><category term="TDD" /><category term="AndroidUITest" /><summary type="html">참고자료 https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin https://two22.tistory.com/12</summary></entry><entry><title type="html">Data structure - Kotlin Collections Overview</title><link href="http://localhost:4000/programming-theory/data-structure-1-kotlin-data-structure/" rel="alternate" type="text/html" title="Data structure - Kotlin Collections Overview" /><published>2020-10-19T00:00:00+09:00</published><updated>2020-10-19T00:00:00+09:00</updated><id>http://localhost:4000/programming-theory/data-structure-1-kotlin-data-structure</id><content type="html" xml:base="http://localhost:4000/programming-theory/data-structure-1-kotlin-data-structure/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://www.tutorialspoint.com/data_structures_algorithms/index.html&quot;&gt;https://www.tutorialspoint.com/data_structures_algorithms/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;코틀린 학습 + 영어 공부를 위해 kotlin 가이드 문서를 번역함&lt;/p&gt;

&lt;h2 id=&quot;kotlin-collections-overview&quot;&gt;Kotlin Collections Overview&lt;/h2&gt;
&lt;p&gt;코틀린 표준 라이브러리는 항목 그룹으로 구성된 컬렉션 관리를 위한 포괄적 도구 세트를 제공하며, 이러한 툴은 해결된 문제에 대한 중요성을 공유하고 공통적으로 운영된다.&lt;/p&gt;

&lt;p&gt;컬렉션은 일반적으로 동일한 유형의 여러 객체를 포함한다.&lt;/p&gt;

&lt;p&gt;컬렉션안의 객체(object)를 요소(elements) 또는 items라고 한다.&lt;/p&gt;

&lt;p&gt;예를들어, 한 학과의 모든 학생들은 그들의 평균 나이를 계산하는 데 사용될 수 있는 컬렉션을 형성한다. 다음 컬렉션 유형은 kotlin과 관련있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;List&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;List는 지수(indices) - integer numbers(위치를 반영하는 정수)에 의해 요소(elements)에 접근할 수 있는 순서형 집합이다. elements는 list에서 두개 이상 존재할 수 있다. List의 예는 문장이다. 문장은 단어들의 그룹이며, 순서가 중요하며, 반복될 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Set&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Set은 unique elements의 컬렉션이다. 집합(set)의 수학적(mathematical) 추상화(abstraction)를  반영(reflects) 한다.  반복없는 객체의 그룹.  일반적으로, 집합 요소(set elements)의 순서는 의미(significance)가 없다. 예를들면, 알파벳은 글자의 집합이다.  (set of letters)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Map(or dictionary)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Map은 key-value 쌍(pairs)의 집합이다. key는 unique이며 각각은(each of them) 정확히 하나의 값에 maps한다. 값은 중복(duplicates)될수 있다. 객체 사이에서 논리적 연결을(logical connections) 저장하는데(storing) 유용하다(useful). 예를들면 종업원(employee)의 ID와 position처럼.&lt;/p&gt;

&lt;p&gt;코틀린은 컬랙션에 저장된 객체의 정확한 타입의 독립적 컬렉션을  다루도록 해준다.즉,  정수 혹은 사용자 정의(user-defined)같은 방법으로 문자열 목록에 추가한다. kotlin standard library는 모든 타입의 컬렉션을 만들고 채우고 관리하기 위한 일반적인 인터페이스, 클래스, 함수를 제공한다.&lt;/p&gt;

&lt;p&gt;컬렉션 인터페이스와 관련된(related) 함수는 kotlin.collections.package.에 위치한다.&lt;/p&gt;

&lt;h2 id=&quot;collection-types&quot;&gt;Collection types&lt;/h2&gt;

&lt;p&gt;코틀린 표준 라이브러리는 set, list, map과 같은 기본 컬렉션 타입의 구현(implementations)을 제공한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;컬렉션 elements에 accessing하기 위한 작업을(operations) 제공하는 read-only interface.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해당(corresponding) read-only interface를 쓰기 작업으로 확장(extends)하는 변경가능한(mutable) interface.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고로 (Note that) mutable collection을 변경할 때 var이 요구되지 않는다. 쓰기 작업에서 동일한 mutable collection 객체를 수정(modify)하여 참조가 변경되지 않도록 해야한다.  val 컬렉션을 재할당(reassign) 하면 컴파일 에러가 발생한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)   
numbers.add(&quot;five&quot;)   // this is OK    
//numbers = mutableListOf(&quot;six&quot;, &quot;seven&quot;)      // compilation error   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;read-only 컬렉션 type은 공변한다. 이것의 의미는 만약 직사각형 클래스가 shape에서 상속(inherits)되면,  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt;가 요구된 모든 곳에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 을 사용할 수 있다는 것이다. 즉, 컬렉션 타입은  elements 타입과 같은 ‘subtyping(하위형식)’ 관계를 갖는다. map은 값 유형은 공변하지만 key 유형은 공변하지 않는다.&lt;/p&gt;

&lt;p&gt;다시 말하면(In turn), mutable collections 는 공변하지 않는다. 그렇지 않으면(otherwise), runtime failures로 이어질 수 있다. 만약  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt; 의 subtype 이라면 다른 Shape 상속(예를들어 Circle)을 삽입하면 사각형 type의 argument를 (이와같이) 위반할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;diagram-of-the-kotlin-collection-interface&quot;&gt;Diagram of the Kotlin collection interface&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/screenshot/collections-diagram.png&quot; alt=&quot;collection diagram&quot; /&gt;
출처 : &lt;a href=&quot;https://www.tutorialspoint.com/data_structures_algorithms/index.htm&quot;&gt;https://www.tutorialspoint.com/data_structures_algorithms/index.htm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;각 인터페이스와 구현에 대하여 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;collection&quot;&gt;Collection&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; 는 collection 계층(hierarchy)의 root이다. retrieving size(사이즈 검색), item membership checking 등등  read-only collection의 일반적인 행동(common behavior)에 해당하는 인터페이스이다. Collection은  반복 요소 작업을 정의(defines)하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;인터페이스로 부터 상속받는다.  Collection을 다른 collection types 에서 사용하는 함수의  paramiter로 사용할 수 있다. 더 구체적인 경우는 컬렉션의 상속인 List와 Set을 사용한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun printAll(strings: Collection&amp;lt;String&amp;gt;) {
        for(s in strings) print(&quot;$s &quot;)
        println()
    }
    
fun main() {
    val stringList = listOf(&quot;one&quot;, &quot;two&quot;, &quot;one&quot;)
    printAll(stringList)
    
    val stringSet = setOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
    printAll(stringSet)
}

result : 
one two one 
one two three 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MutableCollection&lt;/code&gt; 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove&lt;/code&gt;와 같은 쓰기 작업이 있는 Collection이다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun List&amp;lt;String&amp;gt;.getShortWordsTo(shortWords: MutableList&amp;lt;String&amp;gt;, maxLength: Int) {
    this.filterTo(shortWords) { it.length &amp;lt;= maxLength }
    // throwing away the articles
    val articles = setOf(&quot;a&quot;, &quot;A&quot;, &quot;an&quot;, &quot;An&quot;, &quot;the&quot;, &quot;The&quot;)
    shortWords -= articles
}

fun main() {
    val words = &quot;A long time ago in a galaxy far far away&quot;.split(&quot; &quot;)
    val shortWords = mutableListOf&amp;lt;String&amp;gt;()
    words.getShortWordsTo(shortWords, 3)
    println(shortWords)
}

result :
[ago, in, far, far]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;list&quot;&gt;List&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;는 명시된(specified) 순서대로 요소를 저장하고 요소에 대한 indexed access 를 제공한다.  index의 첫번째 element 0 부터 시작하여 마지막  index까지(list.size - 1)&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val numbers = listOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)
println(&quot;Number of elements: ${numbers.size}&quot;)
println(&quot;Third element: ${numbers.get(2)}&quot;)
println(&quot;Fourth element: ${numbers[3]}&quot;)
println(&quot;Index of element \&quot;two\&quot; ${numbers.indexOf(&quot;two&quot;)}&quot;)

result : 
Number of elements: 4
Third element: three
Fourth element: four
Index of element &quot;two&quot; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;List elements (null 포함)는 복제 (duplicate) 할수있다. (List는 다른 동일한 객체 혹은 단일 객체의 발생 횟수를 포함할 수 있다.) &lt;br /&gt;
두개의 List는 만약 크기가 같거나 구조적(structurally)으로 같은 요소가 같은 position에 있을 경우 동등하다고 간주된다(considered).&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val bob = Person(&quot;Bob&quot;, 31)
val people = listOf(Person(&quot;Adam&quot;, 20), bob, bob)
val people2 = listOf(Person(&quot;Adam&quot;, 20), Person(&quot;Bob&quot;, 31), bob)
println(people == people2)
bob.age = 32
println(people == people2)

result : 
true
false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MtableList&amp;lt;T&amp;gt;&lt;/code&gt;는 예를들어 특정 position에서 특정(specific)요소를 추가하거나 제거하는 특정 리스트 쓰기작업을 하는 List이다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val numbers = mutableListOf(1, 2, 3, 4)
numbers.add(5)
numbers.removeAt(1)
numbers[0] = 0
numbers.shuffle()
println(numbers)

result : 
[4, 5, 0, 3]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;보는것과 같이(As you see) 어떤 측면(aspects)에서 list는 array와 매우 유사(similar)하다. 그러나, Array의 크기는 초기화(initialization)에서 정의되며 절대 변경되지 않지만 List는  미리 정의된(predefined) 크기를 가지지 않으며 list의 크기는 elements의 추가,변경, 삭제와 같은 쓰기작업의 결과로 변경될수 있다는 하나의 중요한 차이점이 있다.&lt;/p&gt;

&lt;h2 id=&quot;set&quot;&gt;Set&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&amp;lt;T&amp;gt;&lt;/code&gt;는 일반적으로 정의되지 않은 (generally undefined) unique elements를 저장한다. null elements도 unique 하다. (Set은 하나의 null만 포함할 수 있기 때문) 두개의 Sets은 같은 크기라면 동일하며, 하나의 Set의 각각의 element는 다른 Set안의 element와 동일하다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val numbers = setOf(1, 2, 3, 4)
println(&quot;Number of elements: ${numbers.size}&quot;)
if (numbers.contains(1)) println(&quot;1 is in the set&quot;)

val numbersBackwards = setOf(4, 3, 2, 1)
println(&quot;The sets are equal: ${numbers == numbersBackwards}&quot;)

result : 
Number of elements: 4
1 is in the set
The sets are equal: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MutableSet&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MutableCollection&lt;/code&gt;의 쓰기 작업이 있는 Set이다.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LinkedHashSet&lt;/code&gt;의 기본 구현은 elements의 삽입  순서를 보존한다.  이런 이유로(Hence), first() 혹은 last() 처럼  순서에 의존(rely)하는 함수는 set에서 예측할수있는(predicatable) 결과를  반환한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val numbers = setOf(1, 2, 3, 4)  // LinkedHashSet is the default implementation
val numbersBackwards = setOf(4, 3, 2, 1)

println(numbers.first() == numbersBackwards.first())
println(numbers.first() == numbersBackwards.last())

result : 
false
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대체가능한(alternative) 구현인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;은 elements 순서에 대하여 아무 말도 하지 않는다. 그래서 그러한 함수를 호출하면 예측할 수 없는(unpredicatable) 결과를 반환한다. 하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;은 같은 elements 수를 저장하는데 적은 메모리를 요구한다.&lt;/p&gt;

&lt;h2 id=&quot;map&quot;&gt;Map&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&amp;lt;K, V&amp;gt;&lt;/code&gt;는 Collection 인터페이스 상속자(inheritor)가 아니다. 하지만,  Kotlin 컬렉션 타입이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&lt;/code&gt;은 key-value 쌍(혹은 항목 entires)을 저장한다. key는 unique 하지만 다른 키는 e동일한 값으로 짝을 지을 수있다(can be paired). &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Map&lt;/code&gt; 인터페이스는 key에 의한 value access, key와 value 의 검색 등의 구체적인(specific) 함수를 제공한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val numbersMap = mapOf(&quot;key1&quot; to 1, &quot;key2&quot; to 2, &quot;key3&quot; to 3, &quot;key4&quot; to 1)

println(&quot;All keys: ${numbersMap.keys}&quot;)
println(&quot;All values: ${numbersMap.values}&quot;)
if (&quot;key2&quot; in numbersMap) println(&quot;Value by key \&quot;key2\&quot;: ${numbersMap[&quot;key2&quot;]}&quot;)    
if (1 in numbersMap.values) println(&quot;The value 1 is in the map&quot;)
if (numbersMap.containsValue(1)) println(&quot;The value 1 is in the map&quot;) // same as previous

result : 
All keys: [key1, key2, key3, key4]
All values: [1, 2, 3, 1]
Value by key &quot;key2&quot;: 2
The value 1 is in the map
The value 1 is in the map
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;같은 쌍을 포함하는(containing) 두개의 map은 쌍의 순서와 관계없이(regardless) 동일하다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val numbersMap = mapOf(&quot;key1&quot; to 1, &quot;key2&quot; to 2, &quot;key3&quot; to 3, &quot;key4&quot; to 1)    
val anotherMap = mapOf(&quot;key2&quot; to 2, &quot;key1&quot; to 1, &quot;key4&quot; to 1, &quot;key3&quot; to 3)

result : 
println(&quot;The maps are equal: ${numbersMap == anotherMap}&quot;)
The maps are equal: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MutableMap&lt;/code&gt;은 쓰기작업이 포함된 Map이다. 예를들어 새로운 key-value 쌍을 추가하거나 지정된 키(given key)와 관련된 값을 update 할 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val numbersMap = mutableMapOf(&quot;one&quot; to 1, &quot;two&quot; to 2)
numbersMap.put(&quot;three&quot;, 3)
numbersMap[&quot;one&quot;] = 11

println(numbersMap)

result : 
{one=11, two=2, three=3}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Map의 기본 구현인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;은 Map이 반복될 때  요소의 삽입 순서를 보존한다. 다시말해 (in turn) 대체 구현(alternative implementation)인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HashMap&lt;/code&gt; 은 순서를 보존하지 않는다.&lt;/p&gt;</content><author><name>Hun</name></author><category term="programming-theory" /><category term="Kotlin" /><category term="DataStructure" /><category term="KotlinDocs" /><summary type="html">참고자료 https://www.tutorialspoint.com/data_structures_algorithms/index.html</summary></entry><entry><title type="html">android local &amp;amp; remote data source - kotlin</title><link href="http://localhost:4000/android-kotlin/android-local-remote-data-source-kotlin/" rel="alternate" type="text/html" title="android local &amp;amp; remote data source - kotlin" /><published>2020-10-15T00:00:00+09:00</published><updated>2020-10-15T00:00:00+09:00</updated><id>http://localhost:4000/android-kotlin/android-local-remote-data-source-kotlin</id><content type="html" xml:base="http://localhost:4000/android-kotlin/android-local-remote-data-source-kotlin/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&quot;&gt;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;script&quot;&gt;Script&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Kotlin&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;data
      &lt;ul&gt;
        &lt;li&gt;source
          &lt;ul&gt;
            &lt;li&gt;BookmarkRepository.kt&lt;/li&gt;
            &lt;li&gt;remote
              &lt;ul&gt;
                &lt;li&gt;BookmarkRemoteDataSource.kt&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;(mock)
      &lt;ul&gt;
        &lt;li&gt;Injection.kt&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;datasourcebookmarkremotedatasourcekt&quot;&gt;data/source/BookmarkRemoteDataSource.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object BookmarkRemoteDataSource : BookmarkDataSource {

    private const val SERVICE_LATENCY_IN_MILLIS = 5000L

    private var BOOKMARKS_SERVICE_DATA = LinkedHashMap&amp;lt;String, Bookmark&amp;gt;(2)

    init {
        addBookmark(&quot;Google&quot;, &quot;Portal&quot;,&quot;https://www.google.com&quot;)
        addBookmark(&quot;Naver&quot;, &quot;Portal&quot;,&quot;https://www.naver.com&quot;)
        addBookmark(&quot;Daum&quot;, &quot;Portal&quot;,&quot;https://www.daum.net&quot;)
    }

    private fun addBookmark(title: String, category: String, url: String) {

        val newBookmark = Bookmark(title, category, url)

        BOOKMARKS_SERVICE_DATA.put(newBookmark.id, newBookmark)
    }

    override fun getBookmarks(callback: BookmarkDataSource.LoadBookmarksCallback) {

        val bookmarks = Lists.newArrayList&amp;lt;Bookmark&amp;gt;(BOOKMARKS_SERVICE_DATA.values)

        // Simulate network
        Handler(Looper.getMainLooper()).postDelayed({
            callback.onBookmarksLoaded(bookmarks)
        }, SERVICE_LATENCY_IN_MILLIS)
    }

    override fun getBookmark(
        bookmarkId: String,
        callback: BookmarkDataSource.GetBookmarkCallback
    ) {

        val bookmark = BOOKMARKS_SERVICE_DATA[bookmarkId]

        // simulate network
        with(Handler(Looper.getMainLooper())) {
            if (bookmark != null) {
                postDelayed({ callback.onBookmarkLoaded(bookmark) }, SERVICE_LATENCY_IN_MILLIS)
            } else {
                postDelayed({ callback.onDataNotAvailable() }, SERVICE_LATENCY_IN_MILLIS)
            }
        }
    }

    override fun saveBookmark(bookmark: Bookmark) {

        BOOKMARKS_SERVICE_DATA.put(bookmark.id, bookmark)
    }

    override fun deleteAllBookmarks() {

        BOOKMARKS_SERVICE_DATA.clear()
    }

    override fun deleteBookmark(bookmarkId: String) {

        BOOKMARKS_SERVICE_DATA.remove(bookmarkId)
    }

    override fun refreshBookmark() {
        //
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;-&amp;gt; 아직 원격 데이터베이스와 api가 셋팅되어있지 않기때문에 cache를 활용하여 임시로 구현&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;LinkedHashMap&amp;lt;String, Bookmark&amp;gt;
  -&amp;gt; id와 bookmark 객체를 crud &lt;br /&gt;
  -&amp;gt; remote database 가 구현이 안되어 있어도 linkedhashmap을 통해 테스트 가능 &lt;br /&gt;
  -&amp;gt; linkedhasmap은 cache 메모리 이며 속도가 빠름 &lt;br /&gt;
      -&amp;gt; 변동이 없는 경우 cache에서 가져오는 편이 속도나 성능면에서 이득 &lt;br /&gt;
      -&amp;gt; remote - cache 를 동기화해주는 로직을 구현해야함&lt;/li&gt;
  &lt;li&gt;init {} &lt;br /&gt;
-&amp;gt; init block 이라 하며 객체 생성시 호출 됨 &lt;br /&gt;
  -&amp;gt; google, naver, daum 이라는 임시 데이터 모델이 객체 생성 시 자동으로 생성되어 linkedhasmap에 추가됨&lt;/li&gt;
  &lt;li&gt;BookmarkDataSource 상속 &lt;br /&gt;
  -&amp;gt; 내부 메소드가 오버라이드 되며 임시 cache linkedmap 를 통해 crud 동작 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;datasourcebookmarkrepositorykt&quot;&gt;data/source/BookmarkRepository.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BookmarkRepository(
    private val bookmarkLocalDataSource: BookmarkDataSource,
    private val bookmarkRemoteDataSource: BookmarkDataSource
) : BookmarkDataSource {

    var cachedBookmarks: LinkedHashMap&amp;lt;String, Bookmark&amp;gt; = LinkedHashMap()

    var cacheIsDirty = false

    private fun refreshCache(bookmarks: List&amp;lt;Bookmark&amp;gt;) {
        cachedBookmarks.clear()
        bookmarks.forEach {
            cacheAndPerform(it) {}
        }
        cacheIsDirty = false
    }

    private fun refreshLocalDataSource(bookmarks: List&amp;lt;Bookmark&amp;gt;) {
        bookmarkLocalDataSource.deleteAllBookmarks()
        for (bookmark in bookmarks) {
            bookmarkLocalDataSource.saveBookmark(bookmark)
        }
    }

    private fun getBookmarkFromRemoteDataSource(callback: BookmarkDataSource.LoadBookmarksCallback) {
        bookmarkRemoteDataSource.getBookmarks(object : BookmarkDataSource.LoadBookmarksCallback {
            override fun onBookmarksLoaded(bookmarks: List&amp;lt;Bookmark&amp;gt;) {
                refreshCache(bookmarks)
                refreshLocalDataSource(bookmarks)

                callback.onBookmarksLoaded(ArrayList(cachedBookmarks.values))
            }

            override fun onDataNotAvailable() {
                callback.onDataNotAvailable()
            }

        })
    }

    private fun getBookmarkId(id: String) = cachedBookmarks[id]

    private inline fun cacheAndPerform(bookmark: Bookmark, perform: (Bookmark) -&amp;gt; Unit) {
        val cachedBookmark =
            Bookmark(
                bookmark.id,
                bookmark.category,
                bookmark.url,
                bookmark.title
            ).apply {
                favicon = bookmark.favicon
                position = bookmark.position
            }

        cachedBookmarks[cachedBookmark.id] = cachedBookmark
        perform(cachedBookmark)
    }

		. . .
		BookmarkDataSource override method 
		. . .


    companion object {

        private var INSTANCE: BookmarkRepository? = null

        @JvmStatic
        fun getInstance(
            bookmarkLocalDataSource: BookmarkDataSource,
            bookmarkRemoteDataSource: BookmarkDataSource
        ) =
            INSTANCE ?: synchronized(BookmarkRepository::class.java) {
                INSTANCE ?: BookmarkRepository(
                    bookmarkLocalDataSource,
                    bookmarkRemoteDataSource
                ).also { INSTANCE = it }
            }

        @JvmStatic
        fun destroyInstance() {
            INSTANCE = null
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;BookmarkDataSource 를 2개 입력받아 remote와 local로 나눔&lt;/li&gt;
  &lt;li&gt;var cachedBookmarks: LinkedHashMap&amp;lt;String, Bookmark&amp;gt; = LinkedHashMap()
    &lt;ul&gt;
      &lt;li&gt;cache의 사용으로 속도와 성능 향상&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;var cacheIsDirty = false&lt;/li&gt;
  &lt;li&gt;Bookmark data에 변동이있는지 구분&lt;/li&gt;
  &lt;li&gt;변동이 없으면 false / 변동이 있으면 true&lt;/li&gt;
  &lt;li&gt;refreshCache()
    &lt;ul&gt;
      &lt;li&gt;LinkedHashMap() 을 refresh 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;refreshLocalDataSource()
    &lt;ul&gt;
      &lt;li&gt;Room Database의 bookmarks 테이블을 refresh함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;getMookmarkRemoteDataSource()
    &lt;ul&gt;
      &lt;li&gt;local에는 없으나 remote에 객체가 존재할 때 (동기화가 안된 상황)
        &lt;ul&gt;
          &lt;li&gt;cache와 room database를 refresh 하여 동기화&lt;/li&gt;
          &lt;li&gt;가져온 객체를 callback으로 반환&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;getBookmarkId()
    &lt;ul&gt;
      &lt;li&gt;cache에서 입력받은 id의 bookmark 객체 찾아 반환&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cacheAndPerform()
    &lt;ul&gt;
      &lt;li&gt;inline fun
        &lt;ul&gt;
          &lt;li&gt;Kotlin은 컴파일 단계에서 함수 타입의 변수(람다)를 FunctionN 인터페이스를 구현한 객체로 저장&lt;/li&gt;
          &lt;li&gt;매개변수에 따라 Function0&lt;R&gt; , Function1&amp;lt;P1, R&amp;gt; ... Function22&amp;lt;...&amp;gt; 까지 제공됨&lt;/R&gt;&lt;/li&gt;
          &lt;li&gt;각각의 람다식마다 객체가 생성되어 메모리에 저장되고 invoke() 함수가 각각 호출되어 메모리할당 및 가상 호출에 의한 런타임 오버헤드 발생&lt;/li&gt;
          &lt;li&gt;람다를 매개로하는 고차함수를 inline fun 으로 정의하여 오버헤드를 줄임&lt;/li&gt;
          &lt;li&gt;직접 객체를 호출하기 보단 함수의 본문을 복붙함&lt;/li&gt;
          &lt;li&gt;saveBookmark() , refreshCache(),  getBookmark() 등 단일 객체를 가져오거나 저장할 때 cahce 상의 객체를 동기화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;(Bookmark) -&amp;gt; Unit
    &lt;ul&gt;
      &lt;li&gt;함수의 반환 구문이 없다는 것을 표현하기 위해 사용 = java의 void&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Hun</name></author><category term="android-kotlin" /><category term="Kotlin" /><category term="Android" /><category term="MVVM" /><category term="Database" /><summary type="html">참고자료 https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin</summary></entry><entry><title type="html">android room local database - kotlin</title><link href="http://localhost:4000/android-kotlin/android-room-local-database-kotlin/" rel="alternate" type="text/html" title="android room local database - kotlin" /><published>2020-10-15T00:00:00+09:00</published><updated>2020-10-15T00:00:00+09:00</updated><id>http://localhost:4000/android-kotlin/android-room-local-database-kotlin</id><content type="html" xml:base="http://localhost:4000/android-kotlin/android-room-local-database-kotlin/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&quot;&gt;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;bookmark&quot;&gt;Bookmark&lt;/h2&gt;
&lt;p float=&quot;left&quot;&gt;
  &lt;img src=&quot;/assets/images/gif/2020-10-1509-47.gif&quot; width=&quot;300&quot; /&gt;
	&lt;img src=&quot;/assets/images/gif/2020-10-1509-48.gif&quot; width=&quot;300&quot; /&gt;
&lt;/p&gt;
&lt;h2 id=&quot;script&quot;&gt;Script&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Kotlin&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;data
      &lt;ul&gt;
        &lt;li&gt;Bookmark.kt&lt;/li&gt;
        &lt;li&gt;source
          &lt;ul&gt;
            &lt;li&gt;BookmarkDataSource.kt&lt;/li&gt;
            &lt;li&gt;BookmarkRepository.kt&lt;/li&gt;
            &lt;li&gt;local
              &lt;ul&gt;
                &lt;li&gt;BookmarkDatabase.kt&lt;/li&gt;
                &lt;li&gt;BookmarkDao.kt&lt;/li&gt;
                &lt;li&gt;BookmarkLocalDataSource.kt&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;util
      &lt;ul&gt;
        &lt;li&gt;AppExecutors.kt&lt;/li&gt;
        &lt;li&gt;DiskIOThreadExecutor.kt&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;bookmarkkt&quot;&gt;Bookmark.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Entity(tableName= &quot;bookmarks&quot;)
data class Bookmark @JvmOverloads constructor (
    @NonNull @PrimaryKey @ColumnInfo(name = &quot;id&quot;) var id: String = UUID.randomUUID().toString(),
    @NonNull @ColumnInfo(name= &quot;title&quot;) var title: String = &quot;&quot;,
    @NonNull @ColumnInfo(name= &quot;url&quot;) var url: String = &quot;&quot;,
    @NonNull @ColumnInfo(name= &quot;category&quot;) var category: String = &quot;&quot;
) {

    @ColumnInfo(name = &quot;position&quot;) var position: Int = 0
    
    @ColumnInfo(name = &quot;favicon&quot;) var favicon: String = &quot;&quot;
    
    val isEmpty
        get() = title.isEmpty()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Bookmark Entity Model&lt;/li&gt;
  &lt;li&gt;Bookmarks Table을 생성하고 id, title 등의 데이터 컬럼 작성&lt;/li&gt;
  &lt;li&gt;Bookmark 객체 생성자&lt;/li&gt;
  &lt;li&gt;@Entity() &lt;br /&gt;
  -&amp;gt; room anotation &lt;br /&gt;
  -&amp;gt; table name 을 입력하고 아래 클래스가 room entity 임을 나타냄&lt;/li&gt;
  &lt;li&gt;data class &lt;br /&gt;
  -&amp;gt; 데이터를 보유하면서 아무것도 하지 않는 model에 특화된 class &lt;br /&gt;
-&amp;gt; @JvmOverloads &lt;br /&gt;
  -&amp;gt; Default 메소드를 사용할 수 있음 &lt;br /&gt;
      -&amp;gt; Java에는 Kotlin 처럼 파라미터 안에 Default 값을 넣을 수 없음 &lt;br /&gt;
      -&amp;gt; @JvmOverloads를 기입하면 java에서 Default 값을 오버로딩하여 할당함 &lt;br /&gt;
-&amp;gt; constructor &lt;br /&gt;
  -&amp;gt; java의 생성자 역할 &lt;br /&gt;
  -&amp;gt; java에서는 클래스 내부에 직접 생성자를 등록해야함 &lt;br /&gt;
      -&amp;gt; Kotlin에선 constructor 를 파라미터 앞에 선언하면 간단하게 생성자 등록 가능 &lt;br /&gt;
          -&amp;gt; 객체 생성시 반드시 필요한 값은 파라미터에 &lt;br /&gt;
          -&amp;gt; 그렇지 않은 값은 클래스 내부에 선언 &lt;br /&gt;
-&amp;gt;  @NonNull, @PrimaryKey, @ColumnInfo &lt;br /&gt;
  -&amp;gt; Room의 anotation&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;datasourcebookmarkdatasourcekt&quot;&gt;data/source/BookmarkDataSource.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface BookmarkDataSource {

    interface LoadBookmarksCallback {
        fun onBookmarksLoaded(bookmarks: List&amp;lt;Bookmark&amp;gt;)
        fun onDataNotAvailable()
    }

    interface GetBookmarkCallback {
        fun onBookmarkLoaded(book: Bookmark)
        fun onDataNotAvailable()
    }

    fun getBookmarks(callback: LoadBookmarksCallback)

    fun getBookmark(bookmarkId: String, callback: GetBookmarkCallback)

    fun saveBookmark(bookmark: Bookmark)

    fun deleteAllBookmarks()

    fun deleteBookmark(bookmarkId: String)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;-&amp;gt; interface &lt;br /&gt;
	-&amp;gt; java와 마찬가지로 해당 interface를 상속받은 클래스는 내부에 구현된 함수를 강제 오버라이드 하게 됨 &lt;br /&gt;
-&amp;gt; LoadBookmarksCallback | GetBookmarkCallbaclk &lt;br /&gt;
	-&amp;gt; 데이터 베이스와 클라이언트 사이에서 단일객체 혹은 복수의 객체들을 체크하여 callback &lt;br /&gt;
-&amp;gt; 나머지는 bookmark객체를 데이터베이스로부터 CRUD를 구현 할 메소드&lt;/p&gt;

&lt;h2 id=&quot;datasourcebookmarkrepositorykt&quot;&gt;data/source/BookmarkRepository.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BookmarkRepository(
    val bookmarksLocalDataSource: BookmarkLocalDataSource
		// 추후 에 remote도 추가 
		// val bookmarkRemoteDataSource : BookmarkRemoteDataSource
) : BookmarkDataSource {

		. . .
		// override method 구현 

    companion object {

        private var INSTANCE: BookmarkRepository? = null

        @JvmStatic
        fun getInstance(bookmarksLocalDataSource: BookmarkLocalDataSource) =
            INSTANCE ?: synchronized(BookmarkRepository::class.java) {
                INSTANCE ?: BookmarkRepository(bookmarksLocalDataSource).also { INSTANCE = it }
            }

        @JvmStatic
        fun destroyInstance() {
            INSTANCE = null
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;-&amp;gt; DataSource(interface)를 입력받음 &lt;br /&gt;
-&amp;gt; BookmarkDataSource 상속받아 내부 메소드 오버라이드 &lt;br /&gt;
-&amp;gt; 추후에 RemoteLocalDataSource.kt 추가 됨 &lt;br /&gt;
	-&amp;gt; Local | Remote &amp;lt;-&amp;gt; 데이터 요청 로직 사이에서 데이터 crud 구현하여 callback 구현&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;companion object &lt;br /&gt;
-&amp;gt; Kotlin에는 자바의 static 메소드가 없음 &lt;br /&gt;
  -&amp;gt; 싱글턴 패턴을 구현하기 위해서 companion object를 마지막에 넣어주어야 함  &lt;br /&gt;
      -&amp;gt; 패키지 전역에서 접근하여 활용&lt;/li&gt;
  &lt;li&gt;@JvmStatic &lt;br /&gt;
-&amp;gt; java에서 해당 코드를 static으로 인지하도록 anotation 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;datasourcelocalbookmarkdatabasekt&quot;&gt;data/source/local/BookmarkDatabase.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Database(entities = [Bookmark::class], version = 1)
abstract class BookmarkDatabase : RoomDatabase() {

    abstract fun bookmarkDao(): BookmarkDao

    companion object {

        private var INSTANCE: BookmarkDatabase? = null

        private val lock = Any()

        fun getInstance(context: Context): BookmarkDatabase {
            synchronized(lock) {
                if (INSTANCE == null) {
                    INSTANCE = Room.databaseBuilder(
                        context.applicationContext,
                        BookmarkDatabase::class.java,
                        &quot;bookmarks.db&quot;
                    ).build()
                }
                return  INSTANCE!!
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;-&amp;gt; abstract class (추상 클래스) &lt;br /&gt;
	-&amp;gt;  인터페이스와 흡사하지만 내부에 선언된 메소드를 강제하지 않음 &lt;br /&gt;
	-&amp;gt;  이 객체를 생성할 경우 bookmarkDao interface를 선택적으로 사용함 &lt;br /&gt;
-&amp;gt; 싱글턴 패턴 &lt;br /&gt;
-&amp;gt; Room.databaseBuilder() 
	-&amp;gt; Bookmark.kt 에 선언된 entity를 기반으로 실제 bookmarks.db라는 파일을 생성하여 실제 로컬 table 생성&lt;/p&gt;

&lt;h2 id=&quot;datasourcelocalbookmarkdaokt&quot;&gt;data/source/local/BookmarkDao.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Dao
interface BookmarkDao {

    @Query(&quot;SELECT * FROM bookmarks&quot;)
    fun getBookmarks(): List&amp;lt;Bookmark&amp;gt;

    @Query(&quot;SELECT * FROM bookmarks WHERE id = :bookmarkId&quot;)
    fun getBookmarkById(bookmarkId: String): Bookmark?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertBookmark(bookmark: Bookmark)

    @Update
    fun updateBookmark(bookmark: Bookmark): Int

    @Query(&quot;DELETE FROM bookmarks WHERE id = :bookmarkId&quot;)
    fun deleteBookmarkById(bookmarkId: String): Int

    @Query(&quot;DELETE FROM bookmarks&quot;) fun deleteBookmarks()
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;-&amp;gt; 실제 Room database에서 활용되는 Query가 메소드로 구현 &lt;br /&gt;
-&amp;gt; BookmarkDatabase 추상 클래스에 선언되어 있음 &lt;br /&gt;
	-&amp;gt; BookmarkDatabase 를 통해 사용 &lt;br /&gt;
-&amp;gt; 실제 Database 의 query 문을 사용&lt;/p&gt;

&lt;h2 id=&quot;datasourcelocalbookmarklocaldatasourcekt&quot;&gt;data/source/local/BookmarkLocalDataSource.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BookmarkLocalDataSource private constructor(
    private val appExecutors: AppExecutors,
    private val bookmarkDao: BookmarkDao
) : BookmarkDataSource {

    override fun getBookmarks(callback: BookmarkDataSource.LoadBookmarksCallback) {
        appExecutors.diskIO.execute {
            val bookmarks = bookmarkDao.getBookmarks()
            appExecutors.mainThread.execute {
                if (bookmarks.isEmpty()) {
                    callback.onDataNotAvailable()
                } else {
                    callback.onBookmarksLoaded(bookmarks)
                }
            }
        }
    }

    override fun getBookmark(
        bookmarkId: String,
        callback: BookmarkDataSource.GetBookmarkCallback
    ) {
        appExecutors.diskIO.execute {
            val bookmark = bookmarkDao.getBookmarkById(bookmarkId)
            appExecutors.mainThread.execute {
                if (bookmark != null) {
                    callback.onBookmarkLoaded(bookmark)
                } else {
                    callback.onDataNotAvailable()
                }
            }
        }
    }

    override fun saveBookmark(bookmark: Bookmark) {
        appExecutors.diskIO.execute { bookmarkDao.insertBookmark(bookmark) }
    }

    override fun deleteAllBookmarks() {
        appExecutors.diskIO.execute { bookmarkDao.deleteBookmarks() }
    }

    override fun deleteBookmark(bookmarkId: String) {
        appExecutors.diskIO.execute { bookmarkDao.deleteBookmarkById(bookmarkId) }
    }

    companion object {
        private var INSTANCE: BookmarkLocalDataSource? = null

        @JvmStatic
        fun getInstance(appExecutors: AppExecutors, bookmarkDao: BookmarkDao): BookmarkLocalDataSource {
            if (INSTANCE == null) {
                synchronized(BookmarkLocalDataSource::javaClass) {
                    INSTANCE = BookmarkLocalDataSource(appExecutors, bookmarkDao)
                }
            }
            return INSTANCE!!
        }

        @VisibleForTesting
        fun clearInstance() {
            INSTANCE = null
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;-&amp;gt; Room database에 실제 접근 할 bookmarkDao 인터페이스를 입력값으로 받음 &lt;br /&gt;
-&amp;gt; 로컬 데이터베이스 사용 시 thread 관리 할 AppExcutors를 입력값으로 받음 &lt;br /&gt;
-&amp;gt; BookmarkDataSource를 상속받음 &lt;br /&gt;
	-&amp;gt; 인터페이스 내부 메소드 오버라이드 &lt;br /&gt;
-&amp;gt; crud 메소드 내부에 bookmarkDao의 쿼리 인터페이스를 활용하여 실제 CRUD 구현 &lt;br /&gt;
	-&amp;gt; crud 결과를 callback 함수를 통해 요청한 로직에 전달&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;companion object 로 싱글턴 패턴 구현과 전역적으로 사용 할 수 있도록 선언&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;utilappexcutorskt&quot;&gt;util/AppExcutors.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open class AppExecutors constructor(
    val diskIO: Executor = DiskIOThreadExecutor(),
    val mainThread: Executor = MainThreadExecutor()
		// 추후 networkIO도 추가됨
		 // val networkIO: Executor = Executors.newFixedThreadPool(THREAD_COUNT)
) {

    private class MainThreadExecutor : Executor {
        private val mainThreadHandler = Handler(Looper.getMainLooper())

        override fun execute(command: Runnable?) {
            if (command != null) {
                mainThreadHandler.post(command)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;-&amp;gt; 데이터베이스 접근 시 MainThread를 사용하면 충돌이 일어나 앱이 멈춰버림 &lt;br /&gt;
	-&amp;gt; 그렇기 때문에 새로운 Thread를 생성해서 사용해야 함   &lt;br /&gt;
	-&amp;gt; AppExcutors는 main, local, network thread를 각각 생성 함 &lt;br /&gt;
		-&amp;gt; 필요에 따라 각각의 thread를 꺼내쓰도록 함&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;open class &lt;br /&gt;
-&amp;gt; java와 다르게 Kotlin은 class와 메소드가 기본적으로 final임  &lt;br /&gt;
  -&amp;gt; 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야함 &lt;br /&gt;
  -&amp;gt; 마찬가지로 오버라이드하고 싶은 메소드 or 프로퍼티 앞에도 open 변경자를 붙여야함&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;utildiskiothreadexecutorkt&quot;&gt;util/DiskIOThreadExecutor.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class DiskIOThreadExecutor : Executor {

    private val diskIO = Executors.newSingleThreadExecutor()

    override fun execute(command: Runnable?) { diskIO.execute(command) }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;-&amp;gt; local database crud 할 때 사용할 thread 를 생성함&lt;/p&gt;</content><author><name>Hun</name></author><category term="android-kotlin" /><category term="Kotlin" /><category term="Android" /><category term="Database" /><category term="MVVM" /><summary type="html">참고자료 https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin</summary></entry><entry><title type="html">How to format date time in room database - kotlin</title><link href="http://localhost:4000/android-kotlin/how-to-format-date-time-in-room-database-kotlin/" rel="alternate" type="text/html" title="How to format date time in room database - kotlin" /><published>2020-10-15T00:00:00+09:00</published><updated>2020-10-15T00:00:00+09:00</updated><id>http://localhost:4000/android-kotlin/how-to-format-date-time-in-room-database-kotlin</id><content type="html" xml:base="http://localhost:4000/android-kotlin/how-to-format-date-time-in-room-database-kotlin/">&lt;p&gt;참고자료 &lt;br /&gt;
&lt;a href=&quot;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&quot;&gt;https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://medium.com/androiddevelopers/room-time-2b4cf9672b98&quot;&gt;https://medium.com/androiddevelopers/room-time-2b4cf9672b98&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/training/data-storage/room/referencing-data?hl=ko&quot;&gt;https://developer.android.com/training/data-storage/room/referencing-data?hl=ko&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;homehomefiltertypekt&quot;&gt;home/HomeFilterType.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum class HomeFilterType {

    RECENT_BOOKMARKS,

    CATEGORY_BOOKMARKS,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;위처럼 Bookmark를 보여줄 home activity에 Recent와 Category로 나누어 데이터를 뿌려줄 계획임
    &lt;ul&gt;
      &lt;li&gt;Recent의 경우 최근에 북마크를 생성 or 클릭 한 순서대로 뿌려줄 계획이라 Date Type의 컬럼이 필요함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;datasourcebookmarkkt&quot;&gt;data/source/Bookmark.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Entity(tableName = &quot;bookmarks&quot;)
data class Bookmark @JvmOverloads constructor(
    @NonNull @ColumnInfo(name = &quot;title&quot;) var title: String = &quot;&quot;,
    @NonNull @ColumnInfo(name = &quot;url&quot;) var url: String = &quot;&quot;,
    @NonNull @ColumnInfo(name = &quot;category&quot;) var category: String = &quot;&quot;,
    @ColumnInfo(name = &quot;selectedAt&quot;) var selectedAt: Date?,
    @PrimaryKey @ColumnInfo(name = &quot;id&quot;) var id: String = UUID.randomUUID().toString()
) {
	. . .
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@ColumnInfo(name = “selectedAt”) var selectedAt: Date?,
    &lt;ul&gt;
      &lt;li&gt;위처럼 등록하여 사용하면 될것이라 생각했지만 동작하지 않았음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/training/data-storage/room/referencing-data?hl=ko&quot;&gt;https://developer.android.com/training/data-storage/room/referencing-data?hl=ko&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;공식 홈페이지에 Date to Long and Long to Date 로 convert하는 방법이 나와있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;datasourcelocalconvertskt&quot;&gt;data/source/local/Converts.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Converters {
    @TypeConverter
    fun fromTimestamp(value: Long?): Date? {
        return value?.let { Date(it) }
    }

    @TypeConverter
    fun dateToTimestamp(date: Date?): Long? {
        return date?.time
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Long to Date / Date to Long 각각의 메소드를 작성
    &lt;ul&gt;
      &lt;li&gt;메소드 위에 @TypeConvert annotaion을 기입하면 Room에 convert 메소드가 등록 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;datasourcelocalbookmarkdatabasekt&quot;&gt;data/source/local/BookmarkDatabase.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Database(entities = [Bookmark::class], version = 1)
@TypeConverters(Converters::class)
abstract class BookmarkDatabase : RoomDatabase() {
	
	abstract fun bookmarkDao(): BookmarkDao
	. . .
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;로컬 데이터베이스 파일을 만드는 BookmarkDatabase 추상 클래스 위에 위에서 생성한 Convert를 입력 (@TypeConverters)
    &lt;ul&gt;
      &lt;li&gt;이제 Data Model (Bookmark.kt) 과 Query (BookmarkDao) 에서 Date 타입을 기입할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;homehomeactivitykt&quot;&gt;home/HomeActivity.kt&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private fun testLocalDatabase() {
    bookmarkRepository = Injection.provideBookmarksRepository(this)

    val localDate = Date()
    val newBookmark = Bookmark(&quot;Google&quot;, &quot;https://www.google.com&quot;, &quot;Portal&quot;, localDate)
    bookmarkRepository.saveBookmark(newBookmark)

    val localDate2 = Date()
    val newBookmark2 = Bookmark(&quot;Naver&quot;, &quot;https://www.naver.com&quot;, &quot;Portal&quot;, localDate2)
    bookmarkRepository.saveBookmark(newBookmark2)

    val localDate3 = Date()
    val newBookmark3 = Bookmark(&quot;Daum&quot;, &quot;https://www.daum.com&quot;, &quot;Portal&quot;, localDate3)
    bookmarkRepository.saveBookmark(newBookmark3)

    val sd = SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;)

    bookmarkRepository.getBookmarks(object : BookmarkDataSource.LoadBookmarksCallback {
        override fun onBookmarksLoaded(bookmarks: List&amp;lt;Bookmark&amp;gt;) {
            for (bookmark in bookmarks) {
                Log.e(
                    &quot;bookmark&quot;,
                    bookmark.id + &quot;\n&quot; +
                            bookmark.title + &quot;\n&quot; +
                            bookmark.url + &quot;\n&quot; +
                            sd.format(bookmark.selectedAt)
                )
            }
        }

        override fun onDataNotAvailable() {
            //
        }
    })

    bookmarkRepository.deleteAllBookmarks()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;bookmark 객체를 임의로 3개씩 생성하고 Date() 메소드를 통해 Date를 입력
    &lt;ul&gt;
      &lt;li&gt;bookmarkRepository 의 saveBookmark() 메소드로 로컬 데이터베이스에 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;bookmarkRepository 의 getBookmarks() 메소드로 저장된 데이터를 가져옴
    &lt;ul&gt;
      &lt;li&gt;SimpleDataFormat 을 활용하여 출력되는 정보를 커스텀
        &lt;ul&gt;
          &lt;li&gt;id , title , url, selectAt(클릭 or 생성 시간) 순으로 로그 찍기
            &lt;h2 id=&quot;결과&quot;&gt;결과&lt;/h2&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/screenshot/2020-10-1520-48-37.png&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;</content><author><name>Hun</name></author><category term="android-kotlin" /><category term="Kotlin" /><category term="MVVM" /><category term="Android" /><category term="Database" /><summary type="html">참고자료 https://github.com/ll0301/architecture-samples/tree/todo-mvvm-live-kotlin https://medium.com/androiddevelopers/room-time-2b4cf9672b98 https://developer.android.com/training/data-storage/room/referencing-data?hl=ko</summary></entry></feed>